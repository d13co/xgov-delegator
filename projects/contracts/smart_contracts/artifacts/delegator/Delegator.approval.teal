#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 1000000
    bytecblock 0x151f7c75 "ERR:PS" "H" "lastAccountId" "committeeOracleApp" "h" "a" "ERR:AH_NX" "ERR:AH" base64(C4EBQw==)
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastAccountId"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/delegator/delegator.algo.ts:36
    // export class Delegator extends AccountIdContract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@18
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x9eb0679e 0x968935c8 0x92a02293 0x13c9bb41 0x142f28b0 0xc6711f2f 0x944cb9a8 0x285f9c53 0x4118ecbf // method "setCommitteeOracleApp(uint64)void", method "syncCommitteeMetadata(byte[32],(address,uint32)[])(uint32,uint32,uint32,(uint32,uint32)[])", method "syncProposalMetadata(uint64)void", method "addAccountAlgoHours(uint64,(address,uint64)[])void", method "removeAccountAlgoHours(uint64,(address,uint64)[])void", method "updateAlgoHourPeriodFinality(uint64,uint64,bool)void", method "getAlgoHourPeriodTotals(uint64)(uint64,bool)", method "getAccountAlgoHours(uint64,address)uint64", method "increaseBudget(uint64)void"
    txna ApplicationArgs 0
    match setCommitteeOracleApp syncCommitteeMetadata syncProposalMetadata addAccountAlgoHours removeAccountAlgoHours updateAlgoHourPeriodFinality getAlgoHourPeriodTotals getAccountAlgoHours increaseBudget
    err

main___algots__.defaultCreate@18:
    // smart_contracts/delegator/delegator.algo.ts:36
    // export class Delegator extends AccountIdContract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/base/utils.algo.ts::u32(v: uint64) -> bytes:
u32:
    // smart_contracts/base/utils.algo.ts:4
    // export function u32(v: uint64) {
    proto 1 1
    // smart_contracts/base/utils.algo.ts:5
    // return new Uint32(v)
    frame_dig -1
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    retsub


// smart_contracts/delegator/delegator.algo.ts::Delegator.setCommitteeOracleApp[routing]() -> void:
setCommitteeOracleApp:
    // smart_contracts/delegator/delegator.algo.ts:50
    // public setCommitteeOracleApp(appId: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/delegator/delegator.algo.ts:51
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:38
    // committeeOracleApp = GlobalState<Application>()
    bytec 4 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:52
    // this.committeeOracleApp.value = appId
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:50
    // public setCommitteeOracleApp(appId: Application): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.syncCommitteeMetadata[routing]() -> void:
syncCommitteeMetadata:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 2
    // smart_contracts/delegator/delegator.algo.ts:60
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    txna ApplicationArgs 1
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 36 // 36
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountWithOffsetHint>
    // smart_contracts/delegator/delegator.algo.ts:61
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:40
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    pushbytes "C"
    swap
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:63
    // ensure(!committeeBox.exists, errCommitteeExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz syncCommitteeMetadata_after_if_else@14
    // smart_contracts/delegator/delegator.algo.ts:63
    // ensure(!committeeBox.exists, errCommitteeExists)
    pushbytes "ERR:C_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncCommitteeMetadata_after_if_else@14:
    // smart_contracts/delegator/delegator.algo.ts:66-69
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:67
    // appId: this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:38
    // committeeOracleApp = GlobalState<Application>()
    bytec 4 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:67
    // appId: this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:66-69
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    pushbytes 0x2fd54100 // method "getCommitteeMetadata(byte[32],bool)(uint32,uint32,uint32,uint32,uint64,uint32,string)"
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:68
    // args: [committeeId, true],
    pushbytes 0x80
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:66-69
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    dig 1
    pushint 28 // 28
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 30 // 30
    ==
    assert // invalid tail pointer at index 6 of (uint32,uint32,uint32,uint32,uint64,uint32,(len+utf8[]))
    uncover 2
    swap
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 32
    +
    ==
    assert // invalid number of bytes for CommitteeMetadata
    // smart_contracts/delegator/delegator.algo.ts:72
    // periodStart: remoteCommittee.periodStart,
    dup
    extract 4 4
    // smart_contracts/delegator/delegator.algo.ts:73
    // periodEnd: remoteCommittee.periodEnd,
    swap
    extract 8 4
    // smart_contracts/delegator/delegator.algo.ts:74
    // extDelegatedVotes: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:71-76
    // const committee: DelegatorCommittee = {
    //   periodStart: remoteCommittee.periodStart,
    //   periodEnd: remoteCommittee.periodEnd,
    //   extDelegatedVotes: u32(0),
    //   extDelegatedAccountVotes: [] as AccountIdWithVotes[],
    // }
    cover 2
    concat
    swap
    concat
    pushbytes 0x000e0000
    concat
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:78
    // let extDelegatedVotes: uint64 = 0
    intc_0 // 0
    bury 7
    intc_0 // 0
    bury 6

syncCommitteeMetadata_for_header@3:
    // smart_contracts/delegator/delegator.algo.ts:79
    // for (const { account, offsetHint } of clone(delegatedAccounts)) {
    dig 5
    dig 2
    <
    bz syncCommitteeMetadata_after_for@7
    dig 2
    extract 2 0
    dig 6
    pushint 36 // 36
    *
    pushint 36 // 36
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 13
    extract 32 4
    // smart_contracts/delegator/delegator.algo.ts:80
    // const localAccountId = this.getOrCreateAccountId(account)
    dig 1
    callsub getOrCreateAccountId
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:81-84
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:82
    // appId: this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:38
    // committeeOracleApp = GlobalState<Application>()
    bytec 4 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:82
    // appId: this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:81-84
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    pushbytes 0x90a45fba // method "getXGovVotingPower(byte[32],address,uint32)uint32"
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dup
    cover 2
    bury 10
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    // smart_contracts/delegator/delegator.algo.ts:85
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    btoi
    dup
    bury 6
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncCommitteeMetadata_after_if_else@10
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 10
    log
    // smart_contracts/delegator/delegator.algo.ts:85
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    pushbytes "ERR:A_NV"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncCommitteeMetadata_after_if_else@10:
    // smart_contracts/delegator/delegator.algo.ts:87
    // extDelegatedVotes += remoteVotes.asUint64()
    dig 6
    dig 5
    +
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:88
    // committee.extDelegatedAccountVotes.push({ accountId: localAccountId, votes: remoteVotes })
    dig 9
    dup
    pushint 12 // 12
    extract_uint16
    dig 1
    len
    dig 2
    dig 2
    uncover 2
    substring3
    dig 11
    dig 11
    concat
    dig 1
    swap
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    uncover 2
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    bury 10
    dig 5
    intc_1 // 1
    +
    bury 6
    b syncCommitteeMetadata_for_header@3

syncCommitteeMetadata_after_for@7:
    // smart_contracts/delegator/delegator.algo.ts:90
    // committee.extDelegatedVotes = u32(extDelegatedVotes)
    dig 6
    callsub u32
    dig 10
    swap
    replace2 8
    // smart_contracts/delegator/delegator.algo.ts:91
    // committeeBox.value = clone(committee)
    dig 1
    dup
    box_del
    pop
    dig 1
    box_put
    // smart_contracts/delegator/delegator.algo.ts:60
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.syncProposalMetadata[routing]() -> void:
syncProposalMetadata:
    // smart_contracts/delegator/delegator.algo.ts:96
    // public syncProposalMetadata(proposalId: Application) {
    txna ApplicationArgs 1
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.addAccountAlgoHours[routing]() -> void:
addAccountAlgoHours:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:110
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:111
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:112
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@15
    // smart_contracts/delegator/delegator.algo.ts:112
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

addAccountAlgoHours_after_if_else@15:
    intc_0 // 0
    bury 4

addAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:114
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz addAccountAlgoHours_after_for@8
    dig 1
    extract 2 0
    dig 4
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 11
    intc_3 // 32
    extract_uint64
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:115
    // const accountId = this.getOrCreateAccountId(account)
    callsub getOrCreateAccountId
    // smart_contracts/delegator/delegator.algo.ts:116
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:44
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 5 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:118
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@11
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:118
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    pushbytes "ERR:AH_EX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

addAccountAlgoHours_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:119
    // box.value = hours
    dig 4
    itob
    dup
    bury 7
    dig 7
    swap
    box_put
    // smart_contracts/delegator/delegator.algo.ts:42
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_2 // "H"
    dig 8
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:122
    // if (totalBox.exists) {
    box_len
    bury 1
    bz addAccountAlgoHours_else_body@5
    // smart_contracts/delegator/delegator.algo.ts:123
    // totalBox.value.totalAlgohours += hours
    dup
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    +
    itob
    intc_0 // 0
    swap
    box_replace

addAccountAlgoHours_after_if_else@6:
    dig 3
    intc_1 // 1
    +
    bury 4
    b addAccountAlgoHours_for_header@2

addAccountAlgoHours_else_body@5:
    // smart_contracts/delegator/delegator.algo.ts:125
    // totalBox.value = { totalAlgohours: hours, final: false }
    dig 6
    pushbytes 0x00
    concat
    box_put
    b addAccountAlgoHours_after_if_else@6

addAccountAlgoHours_after_for@8:
    // smart_contracts/delegator/delegator.algo.ts:110
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.removeAccountAlgoHours[routing]() -> void:
removeAccountAlgoHours:
    intc_0 // 0
    dupn 4
    pushbytes ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:135
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:136
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:137
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz removeAccountAlgoHours_after_if_else@24
    // smart_contracts/delegator/delegator.algo.ts:137
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@24:
    intc_0 // 0
    bury 4

removeAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:139
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz removeAccountAlgoHours_after_for@5
    dig 1
    extract 2 0
    dig 4
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 12
    intc_3 // 32
    extract_uint64
    bury 6
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 6 // "a"
    swap
    concat
    dup
    bury 10
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@8
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    pushbytes "ERR:A_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@8:
    // smart_contracts/base/base.algo.ts:58
    // return accountIdBox.value
    dig 8
    box_get
    assert // Box must have value
    // smart_contracts/delegator/delegator.algo.ts:141
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:44
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 5 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:143
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@12
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:143
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    bytec 7 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@12:
    // smart_contracts/delegator/delegator.algo.ts:144
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    dig 6
    box_get
    assert // Box must have value
    btoi
    dig 5
    ==
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@16
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:144
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    bytec 8 // "ERR:AH"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@16:
    // smart_contracts/delegator/delegator.algo.ts:145
    // box.delete()
    dig 6
    box_del
    pop
    // smart_contracts/delegator/delegator.algo.ts:42
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_2 // "H"
    dig 8
    concat
    dup
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:148
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@20
    // smart_contracts/delegator/delegator.algo.ts:148
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    bytec 7 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@20:
    // smart_contracts/delegator/delegator.algo.ts:149
    // totalBox.value.totalAlgohours -= hours
    dig 5
    dup
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    -
    itob
    intc_0 // 0
    swap
    box_replace
    dig 3
    intc_1 // 1
    +
    bury 4
    b removeAccountAlgoHours_for_header@2

removeAccountAlgoHours_after_for@5:
    // smart_contracts/delegator/delegator.algo.ts:135
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.updateAlgoHourPeriodFinality[routing]() -> void:
updateAlgoHourPeriodFinality:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:158
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    swap
    // smart_contracts/delegator/delegator.algo.ts:160
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:161
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz updateAlgoHourPeriodFinality_after_if_else@3
    // smart_contracts/delegator/delegator.algo.ts:161
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@3:
    // smart_contracts/delegator/delegator.algo.ts:162
    // const box = this.algohourPeriodTotals(periodStart)
    dig 2
    itob
    // smart_contracts/delegator/delegator.algo.ts:42
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_2 // "H"
    swap
    concat
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:163
    // ensure(box.exists, errAlgoHoursNotExist)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz updateAlgoHourPeriodFinality_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:163
    // ensure(box.exists, errAlgoHoursNotExist)
    bytec 7 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:164
    // ensure(box.value.totalAlgohours === totalAlgohours, errAlgoHoursMismatch)
    dig 3
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 2
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz updateAlgoHourPeriodFinality_after_if_else@11
    // smart_contracts/delegator/delegator.algo.ts:164
    // ensure(box.value.totalAlgohours === totalAlgohours, errAlgoHoursMismatch)
    bytec 8 // "ERR:AH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:165
    // box.value.final = final
    dig 3
    dup
    intc_2 // 8
    intc_1 // 1
    box_extract
    intc_0 // 0
    dig 3
    setbit
    intc_2 // 8
    swap
    box_replace
    // smart_contracts/delegator/delegator.algo.ts:158
    // @abimethod({ readonly: true })
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAlgoHourPeriodTotals[routing]() -> void:
getAlgoHourPeriodTotals:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:201
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/delegator/delegator.algo.ts:203
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAlgoHourPeriodTotals_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:203
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAlgoHourPeriodTotals_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:204
    // const box = this.algohourPeriodTotals(periodStart)
    dup
    itob
    // smart_contracts/delegator/delegator.algo.ts:42
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_2 // "H"
    swap
    concat
    dup
    bury 3
    // smart_contracts/delegator/delegator.algo.ts:205
    // return box.exists ? box.value : { totalAlgohours: 0, final: false }
    box_len
    bury 1
    bz getAlgoHourPeriodTotals_ternary_false@3
    dig 1
    box_get
    assert // Box must have value

getAlgoHourPeriodTotals_ternary_merge@4:
    // smart_contracts/delegator/delegator.algo.ts:201
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAlgoHourPeriodTotals_ternary_false@3:
    // smart_contracts/delegator/delegator.algo.ts:205
    // return box.exists ? box.value : { totalAlgohours: 0, final: false }
    pushbytes 0x000000000000000000
    b getAlgoHourPeriodTotals_ternary_merge@4


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours[routing]() -> void:
getAccountAlgoHours:
    intc_0 // 0
    dup
    // smart_contracts/delegator/delegator.algo.ts:214
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/delegator/delegator.algo.ts:216
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAccountAlgoHours_after_if_else@10
    // smart_contracts/delegator/delegator.algo.ts:216
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAccountAlgoHours_after_if_else@10:
    // smart_contracts/delegator/delegator.algo.ts:217
    // const accountId = this.getAccountIdIfExists(account)
    dup
    callsub getAccountIdIfExists
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:218
    // if (accountId.asUint64() === 0) {
    btoi
    bnz getAccountAlgoHours_after_if_else@3
    // smart_contracts/delegator/delegator.algo.ts:219
    // return 0
    intc_0 // 0

getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7:
    // smart_contracts/delegator/delegator.algo.ts:214
    // @abimethod({ readonly: true })
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAccountAlgoHours_after_if_else@3:
    // smart_contracts/delegator/delegator.algo.ts:221
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 1
    itob
    dig 4
    concat
    // smart_contracts/delegator/delegator.algo.ts:44
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 5 // "h"
    swap
    concat
    dup
    bury 4
    // smart_contracts/delegator/delegator.algo.ts:223
    // return box.exists ? box.value : 0
    box_len
    bury 1
    bz getAccountAlgoHours_ternary_false@5
    dig 2
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/delegator/delegator.algo.ts:214
    // @abimethod({ readonly: true })
    b getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7

getAccountAlgoHours_ternary_false@5:
    // smart_contracts/delegator/delegator.algo.ts:223
    // return box.exists ? box.value : 0
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:214
    // @abimethod({ readonly: true })
    b getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7


// smart_contracts/base/base.algo.ts::AccountIdContract.increaseBudget[routing]() -> void:
increaseBudget:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    intc_0 // 0

increaseBudget_while_top@2:
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    dig 2
    <
    bz increaseBudget_after_while@5
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/base/base.algo.ts:95
    // onCompletion: OnCompleteAction.DeleteApplication,
    pushint 5 // 5
    itxn_field OnCompletion
    // smart_contracts/base/base.algo.ts:89
    // const empty = compile(EmptyContract)
    bytec 9 // base64(C4EBQw==)
    itxn_field ClearStateProgramPages
    bytec 9 // base64(C4EBQw==)
    itxn_field ApprovalProgramPages
    // smart_contracts/base/base.algo.ts:91-96
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    intc_1 // 1
    +
    bury 1
    b increaseBudget_while_top@2

increaseBudget_after_while@5:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/base/base.algo.ts::AccountIdContract.getAccountIdIfExists(account: bytes) -> bytes:
getAccountIdIfExists:
    // smart_contracts/base/base.algo.ts:43
    // protected getAccountIdIfExists(account: Account): Uint32 {
    proto 1 1
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 6 // "a"
    frame_dig -1
    concat
    dup
    // smart_contracts/base/base.algo.ts:45
    // if (box.exists) return box.value
    box_len
    bury 1
    bz getAccountIdIfExists_else_body@2
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub

getAccountIdIfExists_else_body@2:
    // smart_contracts/base/base.algo.ts:46
    // else return u32(0)
    intc_0 // 0
    callsub u32
    swap
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.getOrCreateAccountId(account: bytes) -> bytes:
getOrCreateAccountId:
    // smart_contracts/base/base.algo.ts:66
    // protected getOrCreateAccountId(account: Account): Uint32 {
    proto 1 1
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:67
    // let accountId = this.getAccountIdIfExists(account)
    frame_dig -1
    callsub getAccountIdIfExists
    dup
    // smart_contracts/base/base.algo.ts:68
    // if (accountId.asUint64() === 0) {
    btoi
    bnz getOrCreateAccountId_else_body@2
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 6 // "a"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getOrCreateAccountId_after_if_else@5
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    pushbytes "ERR:A_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getOrCreateAccountId_after_if_else@5:
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec_3 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    dig 1
    app_global_put
    // smart_contracts/base/base.algo.ts:33
    // const accountId = u32(this.lastAccountId.value)
    callsub u32
    // smart_contracts/base/base.algo.ts:34
    // box.value = accountId
    frame_dig 0
    dig 1
    box_put
    // smart_contracts/base/base.algo.ts:69
    // return this.createAccountId(account)
    frame_bury 0
    retsub

getOrCreateAccountId_else_body@2:
    // smart_contracts/base/base.algo.ts:71
    // return accountId
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.ensureCallerIsAdmin() -> void:
ensureCallerIsAdmin:
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz ensureCallerIsAdmin_after_if_else@3
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    pushbytes "ERR:AUTH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

ensureCallerIsAdmin_after_if_else@3:
    retsub
