#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 32 40 1000000
    bytecblock 0x151f7c75 "ERR:PS" "lastAccountId" "committeeOracleAppId" "h" "H" "ERR:AH_NX" base64(C4EBQw==)
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "lastAccountId"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/delegator/delegator.algo.ts:35
    // export class Delegator extends AccountIdContract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@16
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x10d588a4 0x968935c8 0x13c9bb41 0x142f28b0 0x842cc173 0x285f9c53 0x4118ecbf // method "setCommitteeOracleAppId(uint64)void", method "syncCommitteeMetadata(byte[32],(address,uint32)[])(uint32,uint32,uint32,(uint32,uint32)[])", method "addAccountAlgoHours(uint64,(address,uint64)[])void", method "removeAccountAlgoHours(uint64,(address,uint64)[])void", method "getAlgoHourPeriodTotals(uint64)uint64", method "getAccountAlgoHours(uint64,address)uint64", method "increaseBudget(uint64)void"
    txna ApplicationArgs 0
    match setCommitteeOracleAppId syncCommitteeMetadata addAccountAlgoHours removeAccountAlgoHours getAlgoHourPeriodTotals getAccountAlgoHours increaseBudget
    err

main___algots__.defaultCreate@16:
    // smart_contracts/delegator/delegator.algo.ts:35
    // export class Delegator extends AccountIdContract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/base/utils.algo.ts::u32(v: uint64) -> bytes:
u32:
    // smart_contracts/base/utils.algo.ts:4
    // export function u32(v: uint64) {
    proto 1 1
    // smart_contracts/base/utils.algo.ts:5
    // return new Uint32(v)
    frame_dig -1
    itob
    dup
    bitlen
    intc_2 // 32
    <=
    assert // overflow
    extract 4 4
    retsub


// smart_contracts/delegator/delegator.algo.ts::Delegator.setCommitteeOracleAppId[routing]() -> void:
setCommitteeOracleAppId:
    // smart_contracts/delegator/delegator.algo.ts:47
    // public setCommitteeOracleAppId(appId: Application): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/delegator/delegator.algo.ts:48
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:36
    // committeeOracleAppId = GlobalState<Application>()
    bytec_3 // "committeeOracleAppId"
    // smart_contracts/delegator/delegator.algo.ts:49
    // this.committeeOracleAppId.value = appId
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:47
    // public setCommitteeOracleAppId(appId: Application): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.syncCommitteeMetadata[routing]() -> void:
syncCommitteeMetadata:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 2
    // smart_contracts/delegator/delegator.algo.ts:57
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 36 // 36
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountWithOffsetHint>
    // smart_contracts/delegator/delegator.algo.ts:58
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:38
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    pushbytes "C"
    swap
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:60
    // ensure(!committeeBox.exists, errCommitteeExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz syncCommitteeMetadata_after_if_else@14
    // smart_contracts/delegator/delegator.algo.ts:60
    // ensure(!committeeBox.exists, errCommitteeExists)
    pushbytes "ERR:C_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncCommitteeMetadata_after_if_else@14:
    // smart_contracts/delegator/delegator.algo.ts:63-66
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleAppId.value,
    //   args: [committeeId, true],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:64
    // appId: this.committeeOracleAppId.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:36
    // committeeOracleAppId = GlobalState<Application>()
    bytec_3 // "committeeOracleAppId"
    // smart_contracts/delegator/delegator.algo.ts:64
    // appId: this.committeeOracleAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:63-66
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleAppId.value,
    //   args: [committeeId, true],
    // }).returnValue
    pushbytes 0x2fd54100 // method "getCommitteeMetadata(byte[32],bool)(uint32,uint32,uint32,uint32,uint64,uint32,string)"
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:65
    // args: [committeeId, true],
    pushbytes 0x80
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:63-66
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleAppId.value,
    //   args: [committeeId, true],
    // }).returnValue
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    dig 1
    pushint 28 // 28
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 30 // 30
    ==
    assert // invalid tail pointer at index 6 of (uint32,uint32,uint32,uint32,uint64,uint32,(len+utf8[]))
    uncover 2
    swap
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 32
    +
    ==
    assert // invalid number of bytes for CommitteeMetadata
    // smart_contracts/delegator/delegator.algo.ts:69
    // periodStart: remoteCommittee.periodStart,
    dup
    extract 4 4
    // smart_contracts/delegator/delegator.algo.ts:70
    // periodEnd: remoteCommittee.periodEnd,
    swap
    extract 8 4
    // smart_contracts/delegator/delegator.algo.ts:71
    // extDelegatedVotes: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:68-73
    // const committee: DelegatorCommittee = {
    //   periodStart: remoteCommittee.periodStart,
    //   periodEnd: remoteCommittee.periodEnd,
    //   extDelegatedVotes: u32(0),
    //   extDelegatedAccountVotes: [] as AccountIdWithVotes[],
    // }
    cover 2
    concat
    swap
    concat
    pushbytes 0x000e0000
    concat
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:75
    // let extDelegatedVotes: uint64 = 0
    intc_0 // 0
    bury 7
    intc_0 // 0
    bury 6

syncCommitteeMetadata_for_header@3:
    // smart_contracts/delegator/delegator.algo.ts:76
    // for (const { account, offsetHint } of clone(delegatedAccounts)) {
    dig 5
    dig 2
    <
    bz syncCommitteeMetadata_after_for@7
    dig 2
    extract 2 0
    dig 6
    pushint 36 // 36
    *
    pushint 36 // 36
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 13
    extract 32 4
    // smart_contracts/delegator/delegator.algo.ts:77
    // const localAccountId = this.mustGetAccountId(account)
    dig 1
    callsub mustGetAccountId
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:78-81
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleAppId.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:79
    // appId: this.committeeOracleAppId.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:36
    // committeeOracleAppId = GlobalState<Application>()
    bytec_3 // "committeeOracleAppId"
    // smart_contracts/delegator/delegator.algo.ts:79
    // appId: this.committeeOracleAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:78-81
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleAppId.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    pushbytes 0x90a45fba // method "getXGovVotingPower(byte[32],address,uint32)uint32"
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dup
    cover 2
    bury 10
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    // smart_contracts/delegator/delegator.algo.ts:82
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    btoi
    dup
    bury 6
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncCommitteeMetadata_after_if_else@10
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 10
    log
    // smart_contracts/delegator/delegator.algo.ts:82
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    pushbytes "ERR:A_NV"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncCommitteeMetadata_after_if_else@10:
    // smart_contracts/delegator/delegator.algo.ts:84
    // extDelegatedVotes += remoteVotes.asUint64()
    dig 6
    dig 5
    +
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:85
    // committee.extDelegatedAccountVotes.push({ accountId: localAccountId, votes: remoteVotes })
    dig 9
    dup
    pushint 12 // 12
    extract_uint16
    dig 1
    len
    dig 2
    dig 2
    uncover 2
    substring3
    dig 11
    dig 11
    concat
    dig 1
    swap
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    uncover 2
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    bury 10
    dig 5
    intc_1 // 1
    +
    bury 6
    b syncCommitteeMetadata_for_header@3

syncCommitteeMetadata_after_for@7:
    // smart_contracts/delegator/delegator.algo.ts:87
    // committee.extDelegatedVotes = u32(extDelegatedVotes)
    dig 6
    callsub u32
    dig 10
    swap
    replace2 8
    // smart_contracts/delegator/delegator.algo.ts:88
    // committeeBox.value = clone(committee)
    dig 1
    dup
    box_del
    pop
    dig 1
    box_put
    // smart_contracts/delegator/delegator.algo.ts:57
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.addAccountAlgoHours[routing]() -> void:
addAccountAlgoHours:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:98
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    intc_3 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:99
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:100
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@15
    // smart_contracts/delegator/delegator.algo.ts:100
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

addAccountAlgoHours_after_if_else@15:
    intc_0 // 0
    bury 4

addAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:102
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz addAccountAlgoHours_after_for@8
    dig 1
    extract 2 0
    dig 4
    intc_3 // 40
    *
    intc_3 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 11
    intc_2 // 32
    extract_uint64
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:103
    // const accountId = this.getOrCreateAccountId(account)
    callsub getOrCreateAccountId
    // smart_contracts/delegator/delegator.algo.ts:104
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:41
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 4 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:106
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@11
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:106
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    pushbytes "ERR:AH_EX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

addAccountAlgoHours_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:107
    // box.value = hours
    dig 4
    itob
    dup
    bury 7
    dig 7
    swap
    box_put
    // smart_contracts/delegator/delegator.algo.ts:40
    // algohourTotals = BoxMap<uint64, uint64>({ keyPrefix: 'H' }) // TODO make into struct and add "finalized" value?
    bytec 5 // "H"
    dig 8
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:110
    // if (totalBox.exists) {
    box_len
    bury 1
    bz addAccountAlgoHours_else_body@5
    // smart_contracts/delegator/delegator.algo.ts:111
    // totalBox.value += hours
    dup
    box_get
    assert // Box must have value
    btoi
    dig 6
    +
    itob
    box_put

addAccountAlgoHours_after_if_else@6:
    dig 3
    intc_1 // 1
    +
    bury 4
    b addAccountAlgoHours_for_header@2

addAccountAlgoHours_else_body@5:
    // smart_contracts/delegator/delegator.algo.ts:113
    // totalBox.value = hours
    dig 6
    box_put
    b addAccountAlgoHours_after_if_else@6

addAccountAlgoHours_after_for@8:
    // smart_contracts/delegator/delegator.algo.ts:98
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.removeAccountAlgoHours[routing]() -> void:
removeAccountAlgoHours:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:123
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    intc_3 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:124
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:125
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz removeAccountAlgoHours_after_if_else@20
    // smart_contracts/delegator/delegator.algo.ts:125
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@20:
    intc_0 // 0
    bury 4

removeAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:127
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz removeAccountAlgoHours_after_for@5
    dig 1
    extract 2 0
    dig 4
    intc_3 // 40
    *
    intc_3 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 11
    intc_2 // 32
    extract_uint64
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:128
    // const accountId = this.getOrCreateAccountId(account)
    callsub getOrCreateAccountId
    // smart_contracts/delegator/delegator.algo.ts:129
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:41
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 4 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:131
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@8
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:131
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    bytec 6 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@8:
    // smart_contracts/delegator/delegator.algo.ts:132
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    dig 6
    box_get
    assert // Box must have value
    btoi
    dig 5
    ==
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@12
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:132
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    pushbytes "ERR:AH"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@12:
    // smart_contracts/delegator/delegator.algo.ts:133
    // box.delete()
    dig 6
    box_del
    pop
    // smart_contracts/delegator/delegator.algo.ts:40
    // algohourTotals = BoxMap<uint64, uint64>({ keyPrefix: 'H' }) // TODO make into struct and add "finalized" value?
    bytec 5 // "H"
    dig 8
    concat
    dup
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:136
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@16
    // smart_contracts/delegator/delegator.algo.ts:136
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    bytec 6 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@16:
    // smart_contracts/delegator/delegator.algo.ts:137
    // totalBox.value -= hours
    dig 5
    dup
    box_get
    assert // Box must have value
    btoi
    dig 6
    -
    itob
    box_put
    dig 3
    intc_1 // 1
    +
    bury 4
    b removeAccountAlgoHours_for_header@2

removeAccountAlgoHours_after_for@5:
    // smart_contracts/delegator/delegator.algo.ts:123
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAlgoHourPeriodTotals[routing]() -> void:
getAlgoHourPeriodTotals:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:167
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/delegator/delegator.algo.ts:169
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAlgoHourPeriodTotals_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:169
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAlgoHourPeriodTotals_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:170
    // const box = this.algohourTotals(periodStart)
    dup
    itob
    // smart_contracts/delegator/delegator.algo.ts:40
    // algohourTotals = BoxMap<uint64, uint64>({ keyPrefix: 'H' }) // TODO make into struct and add "finalized" value?
    bytec 5 // "H"
    swap
    concat
    dup
    bury 3
    // smart_contracts/delegator/delegator.algo.ts:171
    // return box.exists ? box.value : 0
    box_len
    bury 1
    bz getAlgoHourPeriodTotals_ternary_false@3
    dig 1
    box_get
    assert // Box must have value
    btoi

getAlgoHourPeriodTotals_ternary_merge@4:
    // smart_contracts/delegator/delegator.algo.ts:167
    // @abimethod({ readonly: true })
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAlgoHourPeriodTotals_ternary_false@3:
    // smart_contracts/delegator/delegator.algo.ts:171
    // return box.exists ? box.value : 0
    intc_0 // 0
    b getAlgoHourPeriodTotals_ternary_merge@4


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours[routing]() -> void:
getAccountAlgoHours:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:180
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/delegator/delegator.algo.ts:182
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAccountAlgoHours_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:182
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_1 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAccountAlgoHours_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:183
    // const key: AlgohourAccountKey = [periodStart, this.mustGetAccountId(account)]
    dup
    callsub mustGetAccountId
    dig 2
    itob
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:41
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 4 // "h"
    swap
    concat
    dup
    bury 4
    // smart_contracts/delegator/delegator.algo.ts:185
    // return box.exists ? box.value : 0
    box_len
    bury 1
    bz getAccountAlgoHours_ternary_false@3
    dig 2
    box_get
    assert // Box must have value
    btoi

getAccountAlgoHours_ternary_merge@4:
    // smart_contracts/delegator/delegator.algo.ts:180
    // @abimethod({ readonly: true })
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAccountAlgoHours_ternary_false@3:
    // smart_contracts/delegator/delegator.algo.ts:185
    // return box.exists ? box.value : 0
    intc_0 // 0
    b getAccountAlgoHours_ternary_merge@4


// smart_contracts/base/base.algo.ts::AccountIdContract.increaseBudget[routing]() -> void:
increaseBudget:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    intc_0 // 0

increaseBudget_while_top@2:
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    dig 2
    <
    bz increaseBudget_after_while@5
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/base/base.algo.ts:95
    // onCompletion: OnCompleteAction.DeleteApplication,
    pushint 5 // 5
    itxn_field OnCompletion
    // smart_contracts/base/base.algo.ts:89
    // const empty = compile(EmptyContract)
    bytec 7 // base64(C4EBQw==)
    itxn_field ClearStateProgramPages
    bytec 7 // base64(C4EBQw==)
    itxn_field ApprovalProgramPages
    // smart_contracts/base/base.algo.ts:91-96
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    intc_1 // 1
    +
    bury 1
    b increaseBudget_while_top@2

increaseBudget_after_while@5:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/base/base.algo.ts::AccountIdContract.mustGetAccountId(account: bytes) -> bytes:
mustGetAccountId:
    // smart_contracts/base/base.algo.ts:55
    // protected mustGetAccountId(account: Account): Uint32 {
    proto 1 1
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    pushbytes "a"
    frame_dig -1
    concat
    dup
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz mustGetAccountId_after_if_else@3
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    pushbytes "ERR:A_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

mustGetAccountId_after_if_else@3:
    // smart_contracts/base/base.algo.ts:58
    // return accountIdBox.value
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.getOrCreateAccountId(account: bytes) -> bytes:
getOrCreateAccountId:
    // smart_contracts/base/base.algo.ts:66
    // protected getOrCreateAccountId(account: Account): Uint32 {
    proto 1 1
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    pushbytes "a"
    frame_dig -1
    concat
    dup
    // smart_contracts/base/base.algo.ts:45
    // if (box.exists) return box.value
    box_len
    bury 1
    bz getOrCreateAccountId_else_body@7
    frame_dig 1
    box_get
    assert // Box must have value
    frame_bury 0

getOrCreateAccountId_after_inlined_smart_contracts/base/base.algo.ts::AccountIdContract.getAccountIdIfExists@8:
    // smart_contracts/base/base.algo.ts:68
    // if (accountId.asUint64() === 0) {
    frame_dig 0
    btoi
    bnz getOrCreateAccountId_else_body@2
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    frame_dig 1
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getOrCreateAccountId_after_if_else@11
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    pushbytes "ERR:A_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getOrCreateAccountId_after_if_else@11:
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec_2 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    dig 1
    app_global_put
    // smart_contracts/base/base.algo.ts:33
    // const accountId = u32(this.lastAccountId.value)
    callsub u32
    // smart_contracts/base/base.algo.ts:34
    // box.value = accountId
    frame_dig 1
    dig 1
    box_put
    // smart_contracts/base/base.algo.ts:69
    // return this.createAccountId(account)
    frame_bury 0
    retsub

getOrCreateAccountId_else_body@2:
    // smart_contracts/base/base.algo.ts:71
    // return accountId
    retsub

getOrCreateAccountId_else_body@7:
    // smart_contracts/base/base.algo.ts:46
    // else return u32(0)
    intc_0 // 0
    callsub u32
    frame_bury 0
    // smart_contracts/base/base.algo.ts:67
    // let accountId = this.getAccountIdIfExists(account)
    b getOrCreateAccountId_after_inlined_smart_contracts/base/base.algo.ts::AccountIdContract.getAccountIdIfExists@8


// smart_contracts/base/base.algo.ts::AccountIdContract.ensureCallerIsAdmin() -> void:
ensureCallerIsAdmin:
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz ensureCallerIsAdmin_after_if_else@3
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    pushbytes "ERR:AUTH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

ensureCallerIsAdmin_after_if_else@3:
    retsub
