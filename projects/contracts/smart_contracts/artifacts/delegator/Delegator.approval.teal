#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 1000000
    bytecblock 0x151f7c75 "H" "ERR:PS" "committeeOracleApp" "ERR:AH_NX" "lastAccountId" "voteSubmitThreshold" "h" "a" "absenteeMode" "ERR:AH" base64(C4EBQw==)
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "lastAccountId"
    intc_0 // 0
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:55
    // voteSubmitThreshold = GlobalState<uint64>({ initialValue: 3600 * 3 })
    bytec 6 // "voteSubmitThreshold"
    pushint 10800 // 10800
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:57
    // absenteeMode = GlobalState<string>({ initialValue: 'strict' })
    bytec 9 // "absenteeMode"
    pushbytes "strict"
    app_global_put

main_after_if_else@2:
    // smart_contracts/delegator/delegator.algo.ts:51
    // export class Delegator extends AccountIdContract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@20
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x9eb0679e 0x0916a587 0xad67f143 0x968935c8 0x425a7332 0x13c9bb41 0x142f28b0 0xc6711f2f 0x944cb9a8 0x285f9c53 0x4118ecbf // method "setCommitteeOracleApp(uint64)void", method "setVoteSubmitThreshold(uint64)void", method "setAbsenteeMode(string)void", method "syncCommitteeMetadata(byte[32],(address,uint32)[])(uint32,uint32,uint32,(uint32,uint32)[])", method "syncProposalMetadata(uint64)(string,byte[32],uint32,uint32,(uint32,uint32)[],(uint32,uint32)[],uint64,uint64,uint64,uint64,uint64,uint64)", method "addAccountAlgoHours(uint64,(address,uint64)[])void", method "removeAccountAlgoHours(uint64,(address,uint64)[])void", method "updateAlgoHourPeriodFinality(uint64,uint64,bool)void", method "getAlgoHourPeriodTotals(uint64)(uint64,bool)", method "getAccountAlgoHours(uint64,address)uint64", method "increaseBudget(uint64)void"
    txna ApplicationArgs 0
    match setCommitteeOracleApp setVoteSubmitThreshold setAbsenteeMode syncCommitteeMetadata syncProposalMetadata addAccountAlgoHours removeAccountAlgoHours updateAlgoHourPeriodFinality getAlgoHourPeriodTotals getAccountAlgoHours increaseBudget
    err

main___algots__.defaultCreate@20:
    // smart_contracts/delegator/delegator.algo.ts:51
    // export class Delegator extends AccountIdContract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/base/utils.algo.ts::u32(v: uint64) -> bytes:
u32:
    // smart_contracts/base/utils.algo.ts:4
    // export function u32(v: uint64) {
    proto 1 1
    // smart_contracts/base/utils.algo.ts:5
    // return new Uint32(v)
    frame_dig -1
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    retsub


// smart_contracts/delegator/delegator.algo.ts::Delegator.setCommitteeOracleApp[routing]() -> void:
setCommitteeOracleApp:
    // smart_contracts/delegator/delegator.algo.ts:71
    // public setCommitteeOracleApp(appId: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/delegator/delegator.algo.ts:72
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:53
    // committeeOracleApp = GlobalState<Application>()
    bytec_3 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:73
    // this.committeeOracleApp.value = appId
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:71
    // public setCommitteeOracleApp(appId: Application): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.setVoteSubmitThreshold[routing]() -> void:
setVoteSubmitThreshold:
    // smart_contracts/delegator/delegator.algo.ts:80
    // public setVoteSubmitThreshold(threshold: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/delegator/delegator.algo.ts:81
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:55
    // voteSubmitThreshold = GlobalState<uint64>({ initialValue: 3600 * 3 })
    bytec 6 // "voteSubmitThreshold"
    // smart_contracts/delegator/delegator.algo.ts:82
    // this.voteSubmitThreshold.value = threshold
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:80
    // public setVoteSubmitThreshold(threshold: uint64): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.setAbsenteeMode[routing]() -> void:
setAbsenteeMode:
    // smart_contracts/delegator/delegator.algo.ts:89
    // public setAbsenteeMode(mode: AbsenteeMode): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/delegator/delegator.algo.ts:90
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:57
    // absenteeMode = GlobalState<string>({ initialValue: 'strict' })
    bytec 9 // "absenteeMode"
    // smart_contracts/delegator/delegator.algo.ts:91
    // this.absenteeMode.value = mode
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:89
    // public setAbsenteeMode(mode: AbsenteeMode): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.syncCommitteeMetadata[routing]() -> void:
syncCommitteeMetadata:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dupn 2
    // smart_contracts/delegator/delegator.algo.ts:99
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    txna ApplicationArgs 1
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 36 // 36
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountWithOffsetHint>
    // smart_contracts/delegator/delegator.algo.ts:100
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:59
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    pushbytes "C"
    swap
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:102
    // ensure(!committeeBox.exists, errCommitteeExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz syncCommitteeMetadata_after_if_else@14
    // smart_contracts/delegator/delegator.algo.ts:102
    // ensure(!committeeBox.exists, errCommitteeExists)
    pushbytes "ERR:C_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncCommitteeMetadata_after_if_else@14:
    // smart_contracts/delegator/delegator.algo.ts:105-108
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:106
    // appId: this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:53
    // committeeOracleApp = GlobalState<Application>()
    bytec_3 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:106
    // appId: this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:105-108
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    pushbytes 0x2fd54100 // method "getCommitteeMetadata(byte[32],bool)(uint32,uint32,uint32,uint32,uint64,uint32,string)"
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:107
    // args: [committeeId, true],
    pushbytes 0x80
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:105-108
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    dig 1
    pushint 28 // 28
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 30 // 30
    ==
    assert // invalid tail pointer at index 6 of (uint32,uint32,uint32,uint32,uint64,uint32,(len+utf8[]))
    uncover 2
    swap
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 32
    +
    ==
    assert // invalid number of bytes for CommitteeMetadata
    // smart_contracts/delegator/delegator.algo.ts:111
    // periodStart: remoteCommittee.periodStart,
    dup
    extract 4 4
    // smart_contracts/delegator/delegator.algo.ts:112
    // periodEnd: remoteCommittee.periodEnd,
    swap
    extract 8 4
    // smart_contracts/delegator/delegator.algo.ts:113
    // extDelegatedVotes: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:110-115
    // const committee: DelegatorCommittee = {
    //   periodStart: remoteCommittee.periodStart,
    //   periodEnd: remoteCommittee.periodEnd,
    //   extDelegatedVotes: u32(0),
    //   extDelegatedAccountVotes: [] as AccountIdWithVotes[],
    // }
    cover 2
    concat
    swap
    concat
    pushbytes 0x000e0000
    concat
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:117
    // let extDelegatedVotes: uint64 = 0
    intc_0 // 0
    bury 7
    intc_0 // 0
    bury 6

syncCommitteeMetadata_for_header@3:
    // smart_contracts/delegator/delegator.algo.ts:118
    // for (const { account, offsetHint } of clone(delegatedAccounts)) {
    dig 5
    dig 2
    <
    bz syncCommitteeMetadata_after_for@7
    dig 2
    extract 2 0
    dig 6
    pushint 36 // 36
    *
    pushint 36 // 36
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 13
    extract 32 4
    // smart_contracts/delegator/delegator.algo.ts:119
    // const localAccountId = this.getOrCreateAccountId(account)
    dig 1
    callsub getOrCreateAccountId
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:120-123
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:121
    // appId: this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:53
    // committeeOracleApp = GlobalState<Application>()
    bytec_3 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:121
    // appId: this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:120-123
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    pushbytes 0x90a45fba // method "getXGovVotingPower(byte[32],address,uint32)uint32"
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dup
    cover 2
    bury 10
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    // smart_contracts/delegator/delegator.algo.ts:124
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    btoi
    dup
    bury 6
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncCommitteeMetadata_after_if_else@10
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 10
    log
    // smart_contracts/delegator/delegator.algo.ts:124
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    pushbytes "ERR:A_NV"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncCommitteeMetadata_after_if_else@10:
    // smart_contracts/delegator/delegator.algo.ts:126
    // extDelegatedVotes += remoteVotes.asUint64()
    dig 6
    dig 5
    +
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:127
    // committee.extDelegatedAccountVotes.push({ accountId: localAccountId, votes: remoteVotes })
    dig 9
    dup
    pushint 12 // 12
    extract_uint16
    dig 1
    len
    dig 2
    dig 2
    uncover 2
    substring3
    dig 11
    dig 11
    concat
    dig 1
    swap
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    uncover 2
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    bury 10
    dig 5
    intc_1 // 1
    +
    bury 6
    b syncCommitteeMetadata_for_header@3

syncCommitteeMetadata_after_for@7:
    // smart_contracts/delegator/delegator.algo.ts:129
    // committee.extDelegatedVotes = u32(extDelegatedVotes)
    dig 6
    callsub u32
    dig 10
    swap
    replace2 8
    // smart_contracts/delegator/delegator.algo.ts:130
    // committeeBox.value = clone(committee)
    dig 1
    dup
    box_del
    pop
    dig 1
    box_put
    // smart_contracts/delegator/delegator.algo.ts:99
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.syncProposalMetadata[routing]() -> void:
syncProposalMetadata:
    intc_0 // 0
    dupn 6
    pushbytes ""
    dupn 5
    // smart_contracts/delegator/delegator.algo.ts:135
    // public syncProposalMetadata(proposalId: Application): DelegatorProposal {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/delegator/delegator.algo.ts:137
    // const proposalBox = this.proposals(proposalId)
    itob
    // smart_contracts/delegator/delegator.algo.ts:61
    // proposals = BoxMap<Application, DelegatorProposal>({ keyPrefix: 'P' })
    pushbytes "P"
    swap
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:138
    // ensure(!proposalBox.exists, errProposalExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz syncProposalMetadata_after_if_else@23
    // smart_contracts/delegator/delegator.algo.ts:138
    // ensure(!proposalBox.exists, errProposalExists)
    pushbytes "ERR:P_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@23:
    // smart_contracts/delegator/delegator.algo.ts:143
    // this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:53
    // committeeOracleApp = GlobalState<Application>()
    bytec_3 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:143
    // this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:144
    // oracleXGovRegistryAppKey,
    pushbytes "xGovRegistryApp"
    // smart_contracts/delegator/delegator.algo.ts:142-145
    // const [registryAppId, registryAppExists] = op.AppGlobal.getExUint64(
    //   this.committeeOracleApp.value,
    //   oracleXGovRegistryAppKey,
    // )
    app_global_get_ex
    swap
    bury 8
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@27
    // smart_contracts/delegator/delegator.algo.ts:146
    // ensure(registryAppExists, errXGovRegistryMissing)
    pushbytes "ERR:XGRM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@27:
    // smart_contracts/delegator/delegator.algo.ts:147
    // const proposalCreator = proposalId.creator
    dig 1
    app_params_get AppCreator
    assert // application exists
    // smart_contracts/delegator/delegator.algo.ts:148
    // const registryEscrow = Application(registryAppId).address
    dig 7
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/delegator/delegator.algo.ts:149
    // ensure(proposalCreator === registryEscrow, errXGovProposalInvalidCreator)
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@31
    // smart_contracts/delegator/delegator.algo.ts:149
    // ensure(proposalCreator === registryEscrow, errXGovProposalInvalidCreator)
    pushbytes "ERR:XGPC"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@31:
    // smart_contracts/delegator/delegator.algo.ts:153
    // const [_committeeId, committeeIdExists] = op.AppGlobal.getExBytes(proposalId, xGovProposalCommitteeIdKey)
    dig 1
    pushbytes "committee_id"
    app_global_get_ex
    swap
    bury 16
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@35
    // smart_contracts/delegator/delegator.algo.ts:154
    // ensure(committeeIdExists, errXGovProposalCommitteeMissing)
    pushbytes "ERR:XGPM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@35:
    // smart_contracts/delegator/delegator.algo.ts:155
    // const committeeId = new StaticBytes<32>(_committeeId)
    dig 14
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    // smart_contracts/delegator/delegator.algo.ts:59
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    pushbytes "C"
    swap
    concat
    dup
    bury 15
    // smart_contracts/delegator/delegator.algo.ts:157
    // ensure(committeeBox.exists, errCommitteeNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@39
    // smart_contracts/delegator/delegator.algo.ts:157
    // ensure(committeeBox.exists, errCommitteeNotExists)
    pushbytes "ERR:C_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@39:
    // smart_contracts/delegator/delegator.algo.ts:158
    // const committeeMetadata = committeeBox.value as Readonly<DelegatorCommittee>
    dig 13
    dup
    box_get
    assert // Box must have value
    dig 1
    intc_0 // 0
    pushint 4 // 4
    box_extract
    dig 2
    pushint 4 // 4
    dup
    box_extract
    bury 14
    uncover 2
    intc_2 // 8
    pushint 4 // 4
    box_extract
    bury 14
    dig 1
    pushint 12 // 12
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    bury 14
    // smart_contracts/delegator/delegator.algo.ts:160
    // let totalAlgoHours: uint64 = 0
    intc_0 // 0
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:163
    // let period: uint64 = committeeMetadata.periodStart.asUint64();
    btoi
    bury 8

syncProposalMetadata_while_top@2:
    // smart_contracts/delegator/delegator.algo.ts:164
    // period < committeeMetadata.periodEnd.asUint64();
    dig 10
    btoi
    dig 8
    >
    // smart_contracts/delegator/delegator.algo.ts:162-166
    // for (
    //   let period: uint64 = committeeMetadata.periodStart.asUint64();
    //   period < committeeMetadata.periodEnd.asUint64();
    //   period += periodLength
    // ) {
    bz syncProposalMetadata_after_while@4
    // smart_contracts/delegator/delegator.algo.ts:167
    // const periodTotalsBox = this.algohourPeriodTotals(period)
    dig 7
    itob
    dup
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:63
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_1 // "H"
    swap
    concat
    dup
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:168
    // ensureExtra(periodTotalsBox.exists, errAlgoHoursNotExist, op.itob(period))
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@15
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:168
    // ensureExtra(periodTotalsBox.exists, errAlgoHoursNotExist, op.itob(period))
    bytec 4 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncProposalMetadata_after_if_else@15:
    // smart_contracts/delegator/delegator.algo.ts:169
    // ensureExtra(periodTotalsBox.value.final, errAlgoHoursNotFinal, op.itob(period))
    dig 8
    box_get
    assert // Box must have value
    pushint 64 // 64
    getbit
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@19
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:169
    // ensureExtra(periodTotalsBox.value.final, errAlgoHoursNotFinal, op.itob(period))
    pushbytes "ERR:AH_NF"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncProposalMetadata_after_if_else@19:
    // smart_contracts/delegator/delegator.algo.ts:171
    // totalAlgoHours += periodTotalsBox.value.totalAlgohours
    dig 8
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    +
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:165
    // period += periodLength
    dig 7
    intc 4 // 1000000
    +
    bury 8
    b syncProposalMetadata_while_top@2

syncProposalMetadata_after_while@4:
    // smart_contracts/delegator/delegator.algo.ts:175
    // const [voteOpenTs, voteOpenTsExists] = op.AppGlobal.getExUint64(proposalId, xGovProposalVoteOpenTsKey)
    dig 1
    dup
    pushbytes "vote_open_ts"
    app_global_get_ex
    cover 2
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:176
    // const [votingDuration, votingDurationExists] = op.AppGlobal.getExUint64(proposalId, xGovProposalVotingDurationKey)
    pushbytes "voting_duration"
    app_global_get_ex
    bury 5
    bury 5
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:177
    // ensure(voteOpenTsExists, errXGovProposalVoteOpenTsMissing)
    pushbytes "ERR:XGVOM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@7:
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    dig 2
    bnz syncProposalMetadata_after_if_else@11
    // smart_contracts/delegator/delegator.algo.ts:178
    // ensure(votingDurationExists, errXGovProposalVotingDurationMissing)
    pushbytes "ERR:XGVDM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:179
    // const voteEndTs: uint64 = voteOpenTs + votingDuration
    dig 4
    dig 4
    +
    // smart_contracts/delegator/delegator.algo.ts:184
    // extVoteEndTime: u32(voteEndTs),
    dup
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:187
    // extAccountsVoted: [] as AccountIdWithVotes[],
    intc_0 // 0
    itob
    // smart_contracts/delegator/delegator.algo.ts:188
    // intVoteEndTime: voteEndTs - this.voteSubmitThreshold.value, // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:55
    // voteSubmitThreshold = GlobalState<uint64>({ initialValue: 3600 * 3 })
    bytec 6 // "voteSubmitThreshold"
    // smart_contracts/delegator/delegator.algo.ts:188
    // intVoteEndTime: voteEndTs - this.voteSubmitThreshold.value, // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    app_global_get_ex
    assert // check GlobalState exists
    uncover 3
    swap
    -
    // smart_contracts/delegator/delegator.algo.ts:181-194
    // const proposalMetadata: DelegatorProposal = {
    //   status: 'WAIT',
    //   committeeId: committeeId,
    //   extVoteEndTime: u32(voteEndTs),
    //   extTotalVotingPower: committeeMetadata.extDelegatedVotes,
    //   extAccountsPendingVotes: clone(committeeMetadata.extDelegatedAccountVotes),
    //   extAccountsVoted: [] as AccountIdWithVotes[],
    //   intVoteEndTime: voteEndTs - this.voteSubmitThreshold.value, // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    //   intTotalAlgohours: totalAlgoHours,
    //   intVotedAlgohours: 0,
    //   intVotesYesAlgohours: 0,
    //   intVotesNoAlgohours: 0,
    //   intVotesBoycottAlgohours: 0,
    // }
    pushbytes 0x005e
    dig 18
    concat
    uncover 3
    concat
    dig 14
    concat
    pushbytes 0x0064
    concat
    dig 15
    dup
    cover 3
    len
    pushint 100 // 100
    +
    itob
    extract 6 2
    concat
    swap
    itob
    concat
    dig 8
    itob
    concat
    dig 2
    concat
    dig 2
    concat
    dig 2
    concat
    uncover 2
    concat
    pushbytes 0x000457414954
    concat
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:187
    // extAccountsVoted: [] as AccountIdWithVotes[],
    pushbytes 0x0000
    // smart_contracts/delegator/delegator.algo.ts:181-194
    // const proposalMetadata: DelegatorProposal = {
    //   status: 'WAIT',
    //   committeeId: committeeId,
    //   extVoteEndTime: u32(voteEndTs),
    //   extTotalVotingPower: committeeMetadata.extDelegatedVotes,
    //   extAccountsPendingVotes: clone(committeeMetadata.extDelegatedAccountVotes),
    //   extAccountsVoted: [] as AccountIdWithVotes[],
    //   intVoteEndTime: voteEndTs - this.voteSubmitThreshold.value, // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    //   intTotalAlgohours: totalAlgoHours,
    //   intVotedAlgohours: 0,
    //   intVotesYesAlgohours: 0,
    //   intVotesNoAlgohours: 0,
    //   intVotesBoycottAlgohours: 0,
    // }
    concat
    // smart_contracts/delegator/delegator.algo.ts:195
    // proposalBox.value = clone(proposalMetadata)
    dig 1
    dup
    box_del
    pop
    dig 1
    box_put
    // smart_contracts/delegator/delegator.algo.ts:135
    // public syncProposalMetadata(proposalId: Application): DelegatorProposal {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.addAccountAlgoHours[routing]() -> void:
addAccountAlgoHours:
    intc_0 // 0
    dupn 3
    pushbytes ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:204
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:205
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:206
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@15
    // smart_contracts/delegator/delegator.algo.ts:206
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

addAccountAlgoHours_after_if_else@15:
    intc_0 // 0
    bury 4

addAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:208
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz addAccountAlgoHours_after_for@8
    dig 1
    extract 2 0
    dig 4
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 11
    intc_3 // 32
    extract_uint64
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:209
    // const accountId = this.getOrCreateAccountId(account)
    callsub getOrCreateAccountId
    // smart_contracts/delegator/delegator.algo.ts:210
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:65
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 7 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:212
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@11
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:212
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    pushbytes "ERR:AH_EX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

addAccountAlgoHours_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:213
    // box.value = hours
    dig 4
    itob
    dup
    bury 7
    dig 7
    swap
    box_put
    // smart_contracts/delegator/delegator.algo.ts:63
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_1 // "H"
    dig 8
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:216
    // if (totalBox.exists) {
    box_len
    bury 1
    bz addAccountAlgoHours_else_body@5
    // smart_contracts/delegator/delegator.algo.ts:217
    // totalBox.value.totalAlgohours += hours
    dup
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    +
    itob
    intc_0 // 0
    swap
    box_replace

addAccountAlgoHours_after_if_else@6:
    dig 3
    intc_1 // 1
    +
    bury 4
    b addAccountAlgoHours_for_header@2

addAccountAlgoHours_else_body@5:
    // smart_contracts/delegator/delegator.algo.ts:219
    // totalBox.value = { totalAlgohours: hours, final: false }
    dig 6
    pushbytes 0x00
    concat
    box_put
    b addAccountAlgoHours_after_if_else@6

addAccountAlgoHours_after_for@8:
    // smart_contracts/delegator/delegator.algo.ts:204
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.removeAccountAlgoHours[routing]() -> void:
removeAccountAlgoHours:
    intc_0 // 0
    dupn 4
    pushbytes ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:229
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:230
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:231
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz removeAccountAlgoHours_after_if_else@24
    // smart_contracts/delegator/delegator.algo.ts:231
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@24:
    intc_0 // 0
    bury 4

removeAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:233
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz removeAccountAlgoHours_after_for@5
    dig 1
    extract 2 0
    dig 4
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 12
    intc_3 // 32
    extract_uint64
    bury 6
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 8 // "a"
    swap
    concat
    dup
    bury 10
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@8
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    pushbytes "ERR:A_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@8:
    // smart_contracts/base/base.algo.ts:58
    // return accountIdBox.value
    dig 8
    box_get
    assert // Box must have value
    // smart_contracts/delegator/delegator.algo.ts:235
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:65
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 7 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:237
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@12
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:237
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    bytec 4 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@12:
    // smart_contracts/delegator/delegator.algo.ts:238
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    dig 6
    box_get
    assert // Box must have value
    btoi
    dig 5
    ==
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@16
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:238
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    bytec 10 // "ERR:AH"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@16:
    // smart_contracts/delegator/delegator.algo.ts:239
    // box.delete()
    dig 6
    box_del
    pop
    // smart_contracts/delegator/delegator.algo.ts:63
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_1 // "H"
    dig 8
    concat
    dup
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:242
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@20
    // smart_contracts/delegator/delegator.algo.ts:242
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    bytec 4 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@20:
    // smart_contracts/delegator/delegator.algo.ts:243
    // totalBox.value.totalAlgohours -= hours
    dig 5
    dup
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    -
    itob
    intc_0 // 0
    swap
    box_replace
    dig 3
    intc_1 // 1
    +
    bury 4
    b removeAccountAlgoHours_for_header@2

removeAccountAlgoHours_after_for@5:
    // smart_contracts/delegator/delegator.algo.ts:229
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.updateAlgoHourPeriodFinality[routing]() -> void:
updateAlgoHourPeriodFinality:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:252
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    swap
    // smart_contracts/delegator/delegator.algo.ts:254
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:255
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz updateAlgoHourPeriodFinality_after_if_else@3
    // smart_contracts/delegator/delegator.algo.ts:255
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@3:
    // smart_contracts/delegator/delegator.algo.ts:256
    // const box = this.algohourPeriodTotals(periodStart)
    dig 2
    itob
    // smart_contracts/delegator/delegator.algo.ts:63
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_1 // "H"
    swap
    concat
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:257
    // ensure(box.exists, errAlgoHoursNotExist)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz updateAlgoHourPeriodFinality_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:257
    // ensure(box.exists, errAlgoHoursNotExist)
    bytec 4 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:258
    // ensure(box.value.totalAlgohours === totalAlgohours, errAlgoHoursMismatch)
    dig 3
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 2
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz updateAlgoHourPeriodFinality_after_if_else@11
    // smart_contracts/delegator/delegator.algo.ts:258
    // ensure(box.value.totalAlgohours === totalAlgohours, errAlgoHoursMismatch)
    bytec 10 // "ERR:AH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:259
    // box.value.final = final
    dig 3
    dup
    intc_2 // 8
    intc_1 // 1
    box_extract
    intc_0 // 0
    dig 3
    setbit
    intc_2 // 8
    swap
    box_replace
    // smart_contracts/delegator/delegator.algo.ts:252
    // @abimethod({ readonly: true })
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAlgoHourPeriodTotals[routing]() -> void:
getAlgoHourPeriodTotals:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:267
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/delegator/delegator.algo.ts:269
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAlgoHourPeriodTotals_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:269
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAlgoHourPeriodTotals_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:270
    // const box = this.algohourPeriodTotals(periodStart)
    dup
    itob
    // smart_contracts/delegator/delegator.algo.ts:63
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_1 // "H"
    swap
    concat
    dup
    bury 3
    // smart_contracts/delegator/delegator.algo.ts:271
    // return box.exists ? box.value : { totalAlgohours: 0, final: false }
    box_len
    bury 1
    bz getAlgoHourPeriodTotals_ternary_false@3
    dig 1
    box_get
    assert // Box must have value

getAlgoHourPeriodTotals_ternary_merge@4:
    // smart_contracts/delegator/delegator.algo.ts:267
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAlgoHourPeriodTotals_ternary_false@3:
    // smart_contracts/delegator/delegator.algo.ts:271
    // return box.exists ? box.value : { totalAlgohours: 0, final: false }
    pushbytes 0x000000000000000000
    b getAlgoHourPeriodTotals_ternary_merge@4


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours[routing]() -> void:
getAccountAlgoHours:
    intc_0 // 0
    dup
    // smart_contracts/delegator/delegator.algo.ts:280
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/delegator/delegator.algo.ts:282
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAccountAlgoHours_after_if_else@10
    // smart_contracts/delegator/delegator.algo.ts:282
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAccountAlgoHours_after_if_else@10:
    // smart_contracts/delegator/delegator.algo.ts:283
    // const accountId = this.getAccountIdIfExists(account)
    dup
    callsub getAccountIdIfExists
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:284
    // if (accountId.asUint64() === 0) {
    btoi
    bnz getAccountAlgoHours_after_if_else@3
    // smart_contracts/delegator/delegator.algo.ts:285
    // return 0
    intc_0 // 0

getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7:
    // smart_contracts/delegator/delegator.algo.ts:280
    // @abimethod({ readonly: true })
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAccountAlgoHours_after_if_else@3:
    // smart_contracts/delegator/delegator.algo.ts:287
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 1
    itob
    dig 4
    concat
    // smart_contracts/delegator/delegator.algo.ts:65
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 7 // "h"
    swap
    concat
    dup
    bury 4
    // smart_contracts/delegator/delegator.algo.ts:289
    // return box.exists ? box.value : 0
    box_len
    bury 1
    bz getAccountAlgoHours_ternary_false@5
    dig 2
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/delegator/delegator.algo.ts:280
    // @abimethod({ readonly: true })
    b getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7

getAccountAlgoHours_ternary_false@5:
    // smart_contracts/delegator/delegator.algo.ts:289
    // return box.exists ? box.value : 0
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:280
    // @abimethod({ readonly: true })
    b getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7


// smart_contracts/base/base.algo.ts::AccountIdContract.increaseBudget[routing]() -> void:
increaseBudget:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    intc_0 // 0

increaseBudget_while_top@2:
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    dig 2
    <
    bz increaseBudget_after_while@5
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/base/base.algo.ts:95
    // onCompletion: OnCompleteAction.DeleteApplication,
    pushint 5 // 5
    itxn_field OnCompletion
    // smart_contracts/base/base.algo.ts:89
    // const empty = compile(EmptyContract)
    bytec 11 // base64(C4EBQw==)
    itxn_field ClearStateProgramPages
    bytec 11 // base64(C4EBQw==)
    itxn_field ApprovalProgramPages
    // smart_contracts/base/base.algo.ts:91-96
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    intc_1 // 1
    +
    bury 1
    b increaseBudget_while_top@2

increaseBudget_after_while@5:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/base/base.algo.ts::AccountIdContract.getAccountIdIfExists(account: bytes) -> bytes:
getAccountIdIfExists:
    // smart_contracts/base/base.algo.ts:43
    // protected getAccountIdIfExists(account: Account): Uint32 {
    proto 1 1
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 8 // "a"
    frame_dig -1
    concat
    dup
    // smart_contracts/base/base.algo.ts:45
    // if (box.exists) return box.value
    box_len
    bury 1
    bz getAccountIdIfExists_else_body@2
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub

getAccountIdIfExists_else_body@2:
    // smart_contracts/base/base.algo.ts:46
    // else return u32(0)
    intc_0 // 0
    callsub u32
    swap
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.getOrCreateAccountId(account: bytes) -> bytes:
getOrCreateAccountId:
    // smart_contracts/base/base.algo.ts:66
    // protected getOrCreateAccountId(account: Account): Uint32 {
    proto 1 1
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:67
    // let accountId = this.getAccountIdIfExists(account)
    frame_dig -1
    callsub getAccountIdIfExists
    dup
    // smart_contracts/base/base.algo.ts:68
    // if (accountId.asUint64() === 0) {
    btoi
    bnz getOrCreateAccountId_else_body@2
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 8 // "a"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getOrCreateAccountId_after_if_else@5
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    pushbytes "ERR:A_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getOrCreateAccountId_after_if_else@5:
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec 5 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    dig 1
    app_global_put
    // smart_contracts/base/base.algo.ts:33
    // const accountId = u32(this.lastAccountId.value)
    callsub u32
    // smart_contracts/base/base.algo.ts:34
    // box.value = accountId
    frame_dig 0
    dig 1
    box_put
    // smart_contracts/base/base.algo.ts:69
    // return this.createAccountId(account)
    frame_bury 0
    retsub

getOrCreateAccountId_else_body@2:
    // smart_contracts/base/base.algo.ts:71
    // return accountId
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.ensureCallerIsAdmin() -> void:
ensureCallerIsAdmin:
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz ensureCallerIsAdmin_after_if_else@3
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    pushbytes "ERR:AUTH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

ensureCallerIsAdmin_after_if_else@3:
    retsub
