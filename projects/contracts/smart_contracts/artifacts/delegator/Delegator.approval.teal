#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 32 1000000
    bytecblock 0x151f7c75 "" "ERR:PS" "H" "committeeOracleApp" "C" "P" "ERR:AH_NX" "h" "a" "lastAccountId" "voteSubmitThreshold" "absenteeMode" 0x000e0000 "ERR:A_NV" "ERR:C_NX" 0x0000 "ERR:AUTH" "ERR:P_NX" "ERR:EAR" "ERR:LAT" "VOTE" "ERR:AH" base64(C4EBQw==)
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec 10 // "lastAccountId"
    intc_0 // 0
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:78
    // voteSubmitThreshold = GlobalState<uint64>({ initialValue: 3600 * 3 })
    bytec 11 // "voteSubmitThreshold"
    pushint 10800 // 10800
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:80
    // absenteeMode = GlobalState<string>({ initialValue: 'strict' })
    bytec 12 // "absenteeMode"
    pushbytes "strict"
    app_global_put

main_after_if_else@2:
    // smart_contracts/delegator/delegator.algo.ts:74
    // export class Delegator extends AccountIdContract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@24
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x9eb0679e 0x0916a587 0xad67f143 0x968935c8 0x270b9b32 0x969ce024 0xb153a98e 0x13c9bb41 0x142f28b0 0xc6711f2f 0x944cb9a8 0x285f9c53 0x6d983f10 0x9bb78145 0x4118ecbf // method "setCommitteeOracleApp(uint64)void", method "setVoteSubmitThreshold(uint64)void", method "setAbsenteeMode(string)void", method "syncCommitteeMetadata(byte[32],(address,uint32)[])(uint32,uint32,uint32,(uint32,uint32)[])", method "syncProposalMetadata(uint64)(string,byte[32],uint32,uint32,uint32,(uint32,uint32)[],(uint32,uint32)[],uint32,uint64,uint64,uint64,uint64,uint64,uint64)", method "voteInternal(uint64,address,(uint64,uint64,uint64,uint64))void", method "voteExternal(uint64,address[])void", method "addAccountAlgoHours(uint64,(address,uint64)[])void", method "removeAccountAlgoHours(uint64,(address,uint64)[])void", method "updateAlgoHourPeriodFinality(uint64,uint64,bool)void", method "getAlgoHourPeriodTotals(uint64)(uint64,bool)", method "getAccountAlgoHours(uint64,address)uint64", method "logCommitteeMetadata(byte[32][])void", method "logProposalMetadata(uint64[])void", method "increaseBudget(uint64)void"
    txna ApplicationArgs 0
    match setCommitteeOracleApp setVoteSubmitThreshold setAbsenteeMode syncCommitteeMetadata syncProposalMetadata voteInternal voteExternal addAccountAlgoHours removeAccountAlgoHours updateAlgoHourPeriodFinality getAlgoHourPeriodTotals getAccountAlgoHours logCommitteeMetadata logProposalMetadata increaseBudget
    err

main___algots__.defaultCreate@24:
    // smart_contracts/delegator/delegator.algo.ts:74
    // export class Delegator extends AccountIdContract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/base/utils.algo.ts::u32(v: uint64) -> bytes:
u32:
    // smart_contracts/base/utils.algo.ts:4
    // export function u32(v: uint64) {
    proto 1 1
    // smart_contracts/base/utils.algo.ts:5
    // return new Uint32(v)
    frame_dig -1
    itob
    dup
    bitlen
    intc_3 // 32
    <=
    assert // overflow
    extract 4 4
    retsub


// smart_contracts/delegator/delegator.algo.ts::Delegator.setCommitteeOracleApp[routing]() -> void:
setCommitteeOracleApp:
    // smart_contracts/delegator/delegator.algo.ts:96
    // public setCommitteeOracleApp(appId: Application): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/delegator/delegator.algo.ts:97
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:76
    // committeeOracleApp = GlobalState<Application>()
    bytec 4 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:98
    // this.committeeOracleApp.value = appId
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:96
    // public setCommitteeOracleApp(appId: Application): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.setVoteSubmitThreshold[routing]() -> void:
setVoteSubmitThreshold:
    // smart_contracts/delegator/delegator.algo.ts:105
    // public setVoteSubmitThreshold(threshold: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/delegator/delegator.algo.ts:106
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:78
    // voteSubmitThreshold = GlobalState<uint64>({ initialValue: 3600 * 3 })
    bytec 11 // "voteSubmitThreshold"
    // smart_contracts/delegator/delegator.algo.ts:107
    // this.voteSubmitThreshold.value = threshold
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:105
    // public setVoteSubmitThreshold(threshold: uint64): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.setAbsenteeMode[routing]() -> void:
setAbsenteeMode:
    // smart_contracts/delegator/delegator.algo.ts:114
    // public setAbsenteeMode(mode: AbsenteeMode): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/delegator/delegator.algo.ts:115
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:80
    // absenteeMode = GlobalState<string>({ initialValue: 'strict' })
    bytec 12 // "absenteeMode"
    // smart_contracts/delegator/delegator.algo.ts:116
    // this.absenteeMode.value = mode
    swap
    app_global_put
    // smart_contracts/delegator/delegator.algo.ts:114
    // public setAbsenteeMode(mode: AbsenteeMode): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.syncCommitteeMetadata[routing]() -> void:
syncCommitteeMetadata:
    intc_0 // 0
    dupn 3
    bytec_1 // ""
    dupn 2
    // smart_contracts/delegator/delegator.algo.ts:124
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    txna ApplicationArgs 1
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 36 // 36
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountWithOffsetHint>
    // smart_contracts/delegator/delegator.algo.ts:125
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:82
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    bytec 5 // "C"
    swap
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:127
    // ensure(!committeeBox.exists, errCommitteeExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz syncCommitteeMetadata_after_if_else@14
    // smart_contracts/delegator/delegator.algo.ts:127
    // ensure(!committeeBox.exists, errCommitteeExists)
    pushbytes "ERR:C_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncCommitteeMetadata_after_if_else@14:
    // smart_contracts/delegator/delegator.algo.ts:130-133
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:131
    // appId: this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:76
    // committeeOracleApp = GlobalState<Application>()
    bytec 4 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:131
    // appId: this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:130-133
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    pushbytes 0x2fd54100 // method "getCommitteeMetadata(byte[32],bool)(uint32,uint32,uint32,uint32,uint64,uint32,string)"
    itxn_field ApplicationArgs
    dig 4
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:132
    // args: [committeeId, true],
    pushbytes 0x80
    itxn_field ApplicationArgs
    // smart_contracts/delegator/delegator.algo.ts:130-133
    // const remoteCommittee = oracleApp.call.getCommitteeMetadata({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, true],
    // }).returnValue
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dig 1
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    dig 1
    pushint 28 // 28
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 30 // 30
    ==
    assert // invalid tail pointer at index 6 of (uint32,uint32,uint32,uint32,uint64,uint32,(len+utf8[]))
    uncover 2
    swap
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 32
    +
    ==
    assert // invalid number of bytes for CommitteeMetadata
    // smart_contracts/delegator/delegator.algo.ts:136
    // periodStart: remoteCommittee.periodStart,
    dup
    extract 4 4
    // smart_contracts/delegator/delegator.algo.ts:137
    // periodEnd: remoteCommittee.periodEnd,
    swap
    extract 8 4
    // smart_contracts/delegator/delegator.algo.ts:138
    // extDelegatedVotes: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:135-140
    // const committee: DelegatorCommittee = {
    //   periodStart: remoteCommittee.periodStart,
    //   periodEnd: remoteCommittee.periodEnd,
    //   extDelegatedVotes: u32(0),
    //   extDelegatedAccountVotes: [] as AccountIdWithVotes[],
    // }
    cover 2
    concat
    swap
    concat
    bytec 13 // 0x000e0000
    concat
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:142
    // let extDelegatedVotes: uint64 = 0
    intc_0 // 0
    bury 7
    intc_0 // 0
    bury 6

syncCommitteeMetadata_for_header@3:
    // smart_contracts/delegator/delegator.algo.ts:143
    // for (const { account, offsetHint } of clone(delegatedAccounts)) {
    dig 5
    dig 2
    <
    bz syncCommitteeMetadata_after_for@7
    dig 2
    extract 2 0
    dig 6
    pushint 36 // 36
    *
    pushint 36 // 36
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 13
    extract 32 4
    // smart_contracts/delegator/delegator.algo.ts:144
    // const localAccountId = this.getOrCreateAccountId(account)
    dig 1
    callsub getOrCreateAccountId
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:145-148
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:146
    // appId: this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:76
    // committeeOracleApp = GlobalState<Application>()
    bytec 4 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:146
    // appId: this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:145-148
    // const remoteVotes = oracleApp.call.getXGovVotingPower({
    //   appId: this.committeeOracleApp.value,
    //   args: [committeeId, account, offsetHint],
    // }).returnValue
    pushbytes 0x90a45fba // method "getXGovVotingPower(byte[32],address,uint32)uint32"
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    dup
    cover 2
    bury 10
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    // smart_contracts/delegator/delegator.algo.ts:149
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    btoi
    dup
    bury 6
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncCommitteeMetadata_after_if_else@10
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 10
    log
    // smart_contracts/delegator/delegator.algo.ts:149
    // ensureExtra(remoteVotes.asUint64() > 0, errNoVotingPower, account.bytes)
    bytec 14 // "ERR:A_NV"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncCommitteeMetadata_after_if_else@10:
    // smart_contracts/delegator/delegator.algo.ts:151
    // extDelegatedVotes += remoteVotes.asUint64()
    dig 6
    dig 5
    +
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:152
    // committee.extDelegatedAccountVotes.push({ accountId: localAccountId, votes: remoteVotes })
    dig 9
    dup
    pushint 12 // 12
    extract_uint16
    dig 1
    len
    dig 2
    dig 2
    uncover 2
    substring3
    dig 11
    dig 11
    concat
    dig 1
    swap
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    uncover 2
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    bury 10
    dig 5
    intc_1 // 1
    +
    bury 6
    b syncCommitteeMetadata_for_header@3

syncCommitteeMetadata_after_for@7:
    // smart_contracts/delegator/delegator.algo.ts:154
    // committee.extDelegatedVotes = u32(extDelegatedVotes)
    dig 6
    callsub u32
    dig 10
    swap
    replace2 8
    // smart_contracts/delegator/delegator.algo.ts:155
    // committeeBox.value = clone(committee)
    dig 1
    dup
    box_del
    pop
    dig 1
    box_put
    // smart_contracts/delegator/delegator.algo.ts:124
    // public syncCommitteeMetadata(committeeId: CommitteeId, delegatedAccounts: AccountWithOffsetHint[]) {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.syncProposalMetadata[routing]() -> void:
syncProposalMetadata:
    intc_0 // 0
    dupn 6
    bytec_1 // ""
    dupn 5
    // smart_contracts/delegator/delegator.algo.ts:160
    // public syncProposalMetadata(proposalId: Application): DelegatorProposal {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/delegator/delegator.algo.ts:162
    // const proposalBox = this.proposals(proposalId)
    itob
    // smart_contracts/delegator/delegator.algo.ts:84
    // proposals = BoxMap<Application, DelegatorProposal>({ keyPrefix: 'P' })
    bytec 6 // "P"
    swap
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:163
    // ensure(!proposalBox.exists, errProposalExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz syncProposalMetadata_after_if_else@23
    // smart_contracts/delegator/delegator.algo.ts:163
    // ensure(!proposalBox.exists, errProposalExists)
    pushbytes "ERR:P_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@23:
    // smart_contracts/delegator/delegator.algo.ts:168
    // this.committeeOracleApp.value,
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:76
    // committeeOracleApp = GlobalState<Application>()
    bytec 4 // "committeeOracleApp"
    // smart_contracts/delegator/delegator.algo.ts:168
    // this.committeeOracleApp.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/delegator/delegator.algo.ts:169
    // oracleXGovRegistryAppKey,
    pushbytes "xGovRegistryApp"
    // smart_contracts/delegator/delegator.algo.ts:167-170
    // const [registryAppId, registryAppExists] = op.AppGlobal.getExUint64(
    //   this.committeeOracleApp.value,
    //   oracleXGovRegistryAppKey,
    // )
    app_global_get_ex
    swap
    bury 8
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@27
    // smart_contracts/delegator/delegator.algo.ts:171
    // ensure(registryAppExists, errXGovRegistryMissing)
    pushbytes "ERR:XGRM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@27:
    // smart_contracts/delegator/delegator.algo.ts:172
    // const proposalCreator = proposalId.creator
    dig 1
    app_params_get AppCreator
    assert // application exists
    // smart_contracts/delegator/delegator.algo.ts:173
    // const registryEscrow = Application(registryAppId).address
    dig 7
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/delegator/delegator.algo.ts:174
    // ensure(proposalCreator === registryEscrow, errXGovProposalInvalidCreator)
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@31
    // smart_contracts/delegator/delegator.algo.ts:174
    // ensure(proposalCreator === registryEscrow, errXGovProposalInvalidCreator)
    pushbytes "ERR:XGPC"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@31:
    // smart_contracts/delegator/delegator.algo.ts:178
    // const [_committeeId, committeeIdExists] = op.AppGlobal.getExBytes(proposalId, xGovProposalCommitteeIdKey)
    dig 1
    pushbytes "committee_id"
    app_global_get_ex
    swap
    bury 16
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@35
    // smart_contracts/delegator/delegator.algo.ts:179
    // ensure(committeeIdExists, errXGovProposalCommitteeMissing)
    pushbytes "ERR:XGPM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@35:
    // smart_contracts/delegator/delegator.algo.ts:180
    // const committeeId = new StaticBytes<32>(_committeeId)
    dig 14
    dup
    len
    intc_3 // 32
    ==
    assert // invalid size
    // smart_contracts/delegator/delegator.algo.ts:82
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    bytec 5 // "C"
    swap
    concat
    dup
    bury 15
    // smart_contracts/delegator/delegator.algo.ts:182
    // ensure(committeeBox.exists, errCommitteeNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@39
    // smart_contracts/delegator/delegator.algo.ts:182
    // ensure(committeeBox.exists, errCommitteeNotExists)
    bytec 15 // "ERR:C_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@39:
    // smart_contracts/delegator/delegator.algo.ts:183
    // const committeeMetadata = committeeBox.value as Readonly<DelegatorCommittee>
    dig 13
    dup
    box_get
    assert // Box must have value
    dig 1
    intc_0 // 0
    pushint 4 // 4
    box_extract
    dig 2
    pushint 4 // 4
    dup
    box_extract
    bury 14
    uncover 2
    intc_2 // 8
    pushint 4 // 4
    box_extract
    bury 14
    dig 1
    pushint 12 // 12
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    bury 14
    // smart_contracts/delegator/delegator.algo.ts:185
    // let totalAlgoHours: uint64 = 0
    intc_0 // 0
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:188
    // let period: uint64 = committeeMetadata.periodStart.asUint64();
    btoi
    bury 8

syncProposalMetadata_while_top@2:
    // smart_contracts/delegator/delegator.algo.ts:189
    // period < committeeMetadata.periodEnd.asUint64();
    dig 10
    btoi
    dig 8
    >
    // smart_contracts/delegator/delegator.algo.ts:187-191
    // for (
    //   let period: uint64 = committeeMetadata.periodStart.asUint64();
    //   period < committeeMetadata.periodEnd.asUint64();
    //   period += periodLength
    // ) {
    bz syncProposalMetadata_after_while@4
    // smart_contracts/delegator/delegator.algo.ts:192
    // const periodTotalsBox = this.algohourPeriodTotals(period)
    dig 7
    itob
    dup
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:86
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_3 // "H"
    swap
    concat
    dup
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:193
    // ensureExtra(periodTotalsBox.exists, errAlgoHoursNotExist, op.itob(period))
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@15
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:193
    // ensureExtra(periodTotalsBox.exists, errAlgoHoursNotExist, op.itob(period))
    bytec 7 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncProposalMetadata_after_if_else@15:
    // smart_contracts/delegator/delegator.algo.ts:194
    // ensureExtra(periodTotalsBox.value.final, errAlgoHoursNotFinal, op.itob(period))
    dig 8
    box_get
    assert // Box must have value
    pushint 64 // 64
    getbit
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@19
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 9
    log
    // smart_contracts/delegator/delegator.algo.ts:194
    // ensureExtra(periodTotalsBox.value.final, errAlgoHoursNotFinal, op.itob(period))
    pushbytes "ERR:AH_NF"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

syncProposalMetadata_after_if_else@19:
    // smart_contracts/delegator/delegator.algo.ts:196
    // totalAlgoHours += periodTotalsBox.value.totalAlgohours
    dig 8
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    +
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:190
    // period += periodLength
    dig 7
    intc 4 // 1000000
    +
    bury 8
    b syncProposalMetadata_while_top@2

syncProposalMetadata_after_while@4:
    // smart_contracts/delegator/delegator.algo.ts:201
    // const [voteOpenTs, voteOpenTsExists] = op.AppGlobal.getExUint64(proposalId, xGovProposalVoteOpenTsKey)
    dig 1
    dup
    pushbytes "vote_open_ts"
    app_global_get_ex
    cover 2
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:202
    // const [votingDuration, votingDurationExists] = op.AppGlobal.getExUint64(proposalId, xGovProposalVotingDurationKey)
    pushbytes "voting_duration"
    app_global_get_ex
    bury 5
    bury 5
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz syncProposalMetadata_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:203
    // ensure(voteOpenTsExists, errXGovProposalVoteOpenTsMissing)
    pushbytes "ERR:XGVOM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@7:
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    dig 2
    bnz syncProposalMetadata_after_if_else@11
    // smart_contracts/delegator/delegator.algo.ts:204
    // ensure(votingDurationExists, errXGovProposalVotingDurationMissing)
    pushbytes "ERR:XGVDM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

syncProposalMetadata_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:205
    // const voteEndTs: uint64 = voteOpenTs + votingDuration
    dig 4
    dup
    dig 5
    +
    // smart_contracts/delegator/delegator.algo.ts:210
    // extVoteStartTime: u32(voteOpenTs),
    swap
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:211
    // extVoteEndTime: u32(voteEndTs),
    dig 1
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:214
    // extAccountsVoted: [] as AccountIdWithVotes[],
    intc_0 // 0
    itob
    // smart_contracts/delegator/delegator.algo.ts:215
    // intVoteEndTime: u32(voteEndTs - this.voteSubmitThreshold.value), // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:78
    // voteSubmitThreshold = GlobalState<uint64>({ initialValue: 3600 * 3 })
    bytec 11 // "voteSubmitThreshold"
    // smart_contracts/delegator/delegator.algo.ts:215
    // intVoteEndTime: u32(voteEndTs - this.voteSubmitThreshold.value), // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    app_global_get_ex
    assert // check GlobalState exists
    uncover 4
    swap
    -
    callsub u32
    // smart_contracts/delegator/delegator.algo.ts:207-222
    // const proposalMetadata: DelegatorProposal = {
    //   status: 'WAIT',
    //   committeeId: committeeId,
    //   extVoteStartTime: u32(voteOpenTs),
    //   extVoteEndTime: u32(voteEndTs),
    //   extTotalVotingPower: committeeMetadata.extDelegatedVotes,
    //   extAccountsPendingVotes: clone(committeeMetadata.extDelegatedAccountVotes),
    //   extAccountsVoted: [] as AccountIdWithVotes[],
    //   intVoteEndTime: u32(voteEndTs - this.voteSubmitThreshold.value), // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    //   intTotalAlgohours: totalAlgoHours,
    //   intVotedAlgohours: 0,
    //   intVotesYesAlgohours: 0,
    //   intVotesNoAlgohours: 0,
    //   intVotesAbstainAlgohours: 0,
    //   intVotesBoycottAlgohours: 0,
    // }
    pushbytes 0x0066
    dig 19
    concat
    uncover 4
    concat
    uncover 3
    concat
    dig 14
    concat
    pushbytes 0x006c
    concat
    dig 15
    dup
    cover 3
    len
    pushint 108 // 108
    +
    itob
    extract 6 2
    concat
    swap
    concat
    dig 8
    itob
    concat
    dig 2
    concat
    dig 2
    concat
    dig 2
    concat
    dig 2
    concat
    uncover 2
    concat
    pushbytes 0x000457414954
    concat
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:214
    // extAccountsVoted: [] as AccountIdWithVotes[],
    bytec 16 // 0x0000
    // smart_contracts/delegator/delegator.algo.ts:207-222
    // const proposalMetadata: DelegatorProposal = {
    //   status: 'WAIT',
    //   committeeId: committeeId,
    //   extVoteStartTime: u32(voteOpenTs),
    //   extVoteEndTime: u32(voteEndTs),
    //   extTotalVotingPower: committeeMetadata.extDelegatedVotes,
    //   extAccountsPendingVotes: clone(committeeMetadata.extDelegatedAccountVotes),
    //   extAccountsVoted: [] as AccountIdWithVotes[],
    //   intVoteEndTime: u32(voteEndTs - this.voteSubmitThreshold.value), // set internal vote end time earlier than external to allow for vote submission before xGov proposal voting ends
    //   intTotalAlgohours: totalAlgoHours,
    //   intVotedAlgohours: 0,
    //   intVotesYesAlgohours: 0,
    //   intVotesNoAlgohours: 0,
    //   intVotesAbstainAlgohours: 0,
    //   intVotesBoycottAlgohours: 0,
    // }
    concat
    // smart_contracts/delegator/delegator.algo.ts:223
    // proposalBox.value = clone(proposalMetadata)
    dig 1
    dup
    box_del
    pop
    dig 1
    box_put
    // smart_contracts/delegator/delegator.algo.ts:160
    // public syncProposalMetadata(proposalId: Application): DelegatorProposal {
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.voteInternal[routing]() -> void:
voteInternal:
    intc_0 // 0
    dupn 8
    bytec_1 // ""
    dupn 11
    // smart_contracts/delegator/delegator.algo.ts:233
    // public voteInternal(proposalId: Application, voterAccount: Account, vote: DelegatorVote): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for smart_contracts/base/types.algo.ts::DelegatorVote
    // smart_contracts/delegator/delegator.algo.ts:235
    // ensure(Txn.sender === voterAccount, errUnauthorized)
    txn Sender
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@26
    // smart_contracts/delegator/delegator.algo.ts:235
    // ensure(Txn.sender === voterAccount, errUnauthorized)
    bytec 17 // "ERR:AUTH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@26:
    // smart_contracts/delegator/delegator.algo.ts:237
    // const proposalBox = this.proposals(proposalId)
    dig 2
    itob
    dup
    bury 20
    // smart_contracts/delegator/delegator.algo.ts:84
    // proposals = BoxMap<Application, DelegatorProposal>({ keyPrefix: 'P' })
    bytec 6 // "P"
    swap
    concat
    dup
    bury 18
    // smart_contracts/delegator/delegator.algo.ts:238
    // ensure(proposalBox.exists, errProposalNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@30
    // smart_contracts/delegator/delegator.algo.ts:238
    // ensure(proposalBox.exists, errProposalNotExists)
    bytec 18 // "ERR:P_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@30:
    // smart_contracts/delegator/delegator.algo.ts:239
    // const proposal = clone(proposalBox.value)
    dig 16
    box_get
    swap
    dup
    cover 2
    bury 20
    assert // Box must have value
    // smart_contracts/delegator/delegator.algo.ts:240
    // ensure(proposal.status !== 'CANC', errProposalCancelled)
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 46 // 46
    extract_uint16
    substring3
    extract 2 0
    pushbytes "CANC"
    !=
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@34
    // smart_contracts/delegator/delegator.algo.ts:240
    // ensure(proposal.status !== 'CANC', errProposalCancelled)
    pushbytes "ERR:P_C"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@34:
    // smart_contracts/delegator/delegator.algo.ts:242
    // const committeeBox = this.committees(proposal.committeeId)
    dig 16
    pushint 2 // 2
    intc_3 // 32
    box_extract
    // smart_contracts/delegator/delegator.algo.ts:82
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    bytec 5 // "C"
    swap
    concat
    dup
    bury 21
    // smart_contracts/delegator/delegator.algo.ts:243
    // ensure(committeeBox.exists, errCommitteeNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@38
    // smart_contracts/delegator/delegator.algo.ts:243
    // ensure(committeeBox.exists, errCommitteeNotExists)
    bytec 15 // "ERR:C_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@38:
    // smart_contracts/delegator/delegator.algo.ts:244
    // const committee = committeeBox.value as Readonly<DelegatorCommittee>
    dig 19
    dup
    intc_0 // 0
    pushint 4 // 4
    box_extract
    bury 22
    pushint 4 // 4
    dup
    box_extract
    bury 22
    // smart_contracts/delegator/delegator.algo.ts:246
    // ensure(proposal.extVoteStartTime.asUint64() <= Global.latestTimestamp, errEarly)
    dig 16
    pushints 34 4 // 34, 4
    box_extract
    btoi
    global LatestTimestamp
    <=
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@42
    // smart_contracts/delegator/delegator.algo.ts:246
    // ensure(proposal.extVoteStartTime.asUint64() <= Global.latestTimestamp, errEarly)
    bytec 19 // "ERR:EAR"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@42:
    // smart_contracts/delegator/delegator.algo.ts:247
    // ensure(Global.latestTimestamp < proposal.intVoteEndTime.asUint64(), errLate)
    global LatestTimestamp
    dig 17
    pushints 50 4 // 50, 4
    box_extract
    btoi
    <
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@46
    // smart_contracts/delegator/delegator.algo.ts:247
    // ensure(Global.latestTimestamp < proposal.intVoteEndTime.asUint64(), errLate)
    bytec 20 // "ERR:LAT"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@46:
    // smart_contracts/delegator/delegator.algo.ts:250
    // committee.periodStart.asUint64(),
    dig 20
    btoi
    dup
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:251
    // committee.periodEnd.asUint64(),
    dig 22
    btoi
    dup
    bury 13
    // smart_contracts/delegator/delegator.algo.ts:422
    // ensure(periodEnd > periodStart, errPeriodEndLessThanStart)
    <
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@50
    // smart_contracts/delegator/delegator.algo.ts:422
    // ensure(periodEnd > periodStart, errPeriodEndLessThanStart)
    pushbytes "ERR:PE_LT"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@50:
    // smart_contracts/delegator/delegator.algo.ts:423
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    dig 9
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz voteInternal_after_if_else@54
    // smart_contracts/delegator/delegator.algo.ts:423
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@54:
    // smart_contracts/delegator/delegator.algo.ts:424
    // ensure(periodEnd % periodLength === 0, errPeriodEndInvalid)
    dig 10
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz voteInternal_after_if_else@58
    // smart_contracts/delegator/delegator.algo.ts:424
    // ensure(periodEnd % periodLength === 0, errPeriodEndInvalid)
    pushbytes "ERR:PE"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@58:
    // smart_contracts/delegator/delegator.algo.ts:425
    // const accountId = this.getAccountIdIfExists(account)
    dig 1
    callsub getAccountIdIfExists
    dup
    bury 25
    // smart_contracts/delegator/delegator.algo.ts:426
    // if (accountId.asUint64() === 0) {
    btoi
    bnz voteInternal_after_if_else@8
    // smart_contracts/delegator/delegator.algo.ts:427
    // return 0
    intc_0 // 0
    bury 4

voteInternal_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAggregatedAccountAlgoHours@15:
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    dig 3
    bnz voteInternal_after_if_else@18
    // smart_contracts/delegator/delegator.algo.ts:254
    // ensure(votingPower > 0, errNoVotingPower)
    bytec 14 // "ERR:A_NV"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@18:
    // smart_contracts/delegator/delegator.algo.ts:255
    // const totalVotesCast: uint64 = vote.yesVotes + vote.noVotes + vote.boycottVotes + vote.abstainVotes
    dupn 2
    intc_0 // 0
    extract_uint64
    dup
    cover 2
    bury 10
    dup
    intc_2 // 8
    extract_uint64
    dup
    bury 10
    uncover 2
    +
    dig 1
    pushint 24 // 24
    extract_uint64
    dup
    bury 9
    +
    swap
    pushint 16 // 16
    extract_uint64
    dup
    bury 7
    +
    dup
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:256
    // ensure(totalVotesCast === votingPower, errIncorrectVotes)
    dig 4
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteInternal_after_if_else@22
    // smart_contracts/delegator/delegator.algo.ts:256
    // ensure(totalVotesCast === votingPower, errIncorrectVotes)
    pushbytes "ERR:IV"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteInternal_after_if_else@22:
    // smart_contracts/delegator/delegator.algo.ts:258
    // const voterAccountId = this.mustGetAccountId(voterAccount)
    dig 1
    callsub mustGetAccountId
    // smart_contracts/delegator/delegator.algo.ts:259
    // const voteBoxKey: VoteKey = [proposalId, voterAccountId]
    dig 19
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:90
    // votes = BoxMap<VoteKey, DelegatorVote>({ keyPrefix: 'V' })
    pushbytes "V"
    swap
    concat
    dup
    bury 17
    // smart_contracts/delegator/delegator.algo.ts:262
    // if (voteBox.exists) {
    box_len
    bury 1
    bz voteInternal_after_if_else@3
    // smart_contracts/delegator/delegator.algo.ts:264
    // const previousVote = voteBox.value as Readonly<DelegatorVote>
    dig 15
    box_get
    assert // Box must have value
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_2 // 8
    extract_uint64
    dig 2
    pushint 16 // 16
    extract_uint64
    uncover 3
    pushint 24 // 24
    extract_uint64
    // smart_contracts/delegator/delegator.algo.ts:266
    // proposal.intVotedAlgohours -= totalVotesCast
    dig 20
    pushint 62 // 62
    intc_2 // 8
    box_extract
    btoi
    dig 13
    -
    itob
    dig 22
    swap
    replace2 62
    // smart_contracts/delegator/delegator.algo.ts:267
    // proposal.intVotesYesAlgohours -= previousVote.yesVotes
    dup
    pushint 70 // 70
    extract_uint64
    uncover 5
    -
    itob
    replace2 70
    // smart_contracts/delegator/delegator.algo.ts:268
    // proposal.intVotesNoAlgohours -= previousVote.noVotes
    dup
    pushint 78 // 78
    extract_uint64
    uncover 4
    -
    itob
    replace2 78
    // smart_contracts/delegator/delegator.algo.ts:269
    // proposal.intVotesBoycottAlgohours -= previousVote.boycottVotes
    dup
    pushint 94 // 94
    extract_uint64
    uncover 2
    -
    itob
    replace2 94
    // smart_contracts/delegator/delegator.algo.ts:270
    // proposal.intVotesAbstainAlgohours -= previousVote.abstainVotes
    dup
    pushint 86 // 86
    extract_uint64
    uncover 2
    -
    itob
    replace2 86
    bury 18

voteInternal_after_if_else@3:
    // smart_contracts/delegator/delegator.algo.ts:273
    // if (proposal.status !== 'VOTE') {
    dig 17
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    bury 17
    dup
    pushint 46 // 46
    extract_uint16
    dup
    bury 17
    swap
    cover 2
    substring3
    extract 2 0
    bytec 21 // "VOTE"
    !=
    bz voteInternal_after_if_else@5
    // smart_contracts/delegator/delegator.algo.ts:274
    // proposal.status = 'VOTE'
    dig 17
    dup
    intc_0 // 0
    dig 17
    dup
    cover 4
    extract3
    pushbytes 0x0004564f5445
    concat
    dig 1
    len
    dig 2
    dig 18
    dup
    cover 3
    uncover 2
    substring3
    uncover 2
    swap
    concat
    dig 1
    uncover 4
    -
    uncover 2
    pushint 6 // 6
    +
    dig 1
    -
    itob
    extract 6 2
    uncover 2
    swap
    replace2 46
    uncover 2
    pushint 48 // 48
    extract_uint16
    pushint 6 // 6
    +
    uncover 2
    -
    itob
    extract 6 2
    replace2 48
    bury 18

voteInternal_after_if_else@5:
    // smart_contracts/delegator/delegator.algo.ts:276
    // proposal.intVotedAlgohours += totalVotesCast
    dig 17
    dup
    pushint 62 // 62
    extract_uint64
    dig 10
    +
    itob
    replace2 62
    // smart_contracts/delegator/delegator.algo.ts:277
    // proposal.intVotesYesAlgohours += vote.yesVotes
    dup
    pushint 70 // 70
    extract_uint64
    dig 9
    +
    itob
    replace2 70
    // smart_contracts/delegator/delegator.algo.ts:278
    // proposal.intVotesNoAlgohours += vote.noVotes
    dup
    pushint 78 // 78
    extract_uint64
    dig 8
    +
    itob
    replace2 78
    // smart_contracts/delegator/delegator.algo.ts:279
    // proposal.intVotesBoycottAlgohours += vote.boycottVotes
    dup
    pushint 94 // 94
    extract_uint64
    dig 7
    +
    itob
    replace2 94
    // smart_contracts/delegator/delegator.algo.ts:280
    // proposal.intVotesAbstainAlgohours += vote.abstainVotes
    dup
    pushint 86 // 86
    extract_uint64
    dig 6
    +
    itob
    replace2 86
    // smart_contracts/delegator/delegator.algo.ts:281
    // voteBox.value = clone(vote)
    dig 16
    dig 2
    box_put
    // smart_contracts/delegator/delegator.algo.ts:282
    // proposalBox.value = clone(proposal)
    dig 17
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/delegator/delegator.algo.ts:233
    // public voteInternal(proposalId: Application, voterAccount: Account, vote: DelegatorVote): void {
    intc_1 // 1
    return

voteInternal_after_if_else@8:
    // smart_contracts/delegator/delegator.algo.ts:429
    // let algohours: uint64 = 0
    intc_0 // 0
    bury 13
    dig 9
    bury 12

voteInternal_while_top@9:
    // smart_contracts/delegator/delegator.algo.ts:430
    // for (let period = periodStart; period < periodEnd; period += periodLength) {
    dig 11
    dig 11
    <
    bz voteInternal_after_while@14
    // smart_contracts/delegator/delegator.algo.ts:431
    // const key: AlgohourAccountKey = [period, accountId]
    dig 11
    itob
    dig 24
    concat
    // smart_contracts/delegator/delegator.algo.ts:88
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 8 // "h"
    swap
    concat
    dup
    bury 24
    // smart_contracts/delegator/delegator.algo.ts:433
    // algohours += box.exists ? box.value : 0
    box_len
    bury 1
    bz voteInternal_ternary_false@12
    dig 22
    box_get
    assert // Box must have value
    btoi

voteInternal_ternary_merge@13:
    // smart_contracts/delegator/delegator.algo.ts:433
    // algohours += box.exists ? box.value : 0
    dig 13
    +
    bury 13
    // smart_contracts/delegator/delegator.algo.ts:430
    // for (let period = periodStart; period < periodEnd; period += periodLength) {
    dig 11
    intc 4 // 1000000
    +
    bury 12
    b voteInternal_while_top@9

voteInternal_ternary_false@12:
    // smart_contracts/delegator/delegator.algo.ts:433
    // algohours += box.exists ? box.value : 0
    intc_0 // 0
    b voteInternal_ternary_merge@13

voteInternal_after_while@14:
    dig 12
    bury 4
    // smart_contracts/delegator/delegator.algo.ts:249-253
    // const votingPower = this.getAggregatedAccountAlgoHours(
    //   committee.periodStart.asUint64(),
    //   committee.periodEnd.asUint64(),
    //   voterAccount,
    // )
    b voteInternal_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAggregatedAccountAlgoHours@15


// smart_contracts/delegator/delegator.algo.ts::Delegator.voteExternal[routing]() -> void:
voteExternal:
    intc_0 // 0
    dupn 3
    bytec_1 // ""
    dupn 7
    // smart_contracts/delegator/delegator.algo.ts:296
    // public voteExternal(proposalId: Application, extAccounts: Account[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    intc_3 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<account>
    // smart_contracts/delegator/delegator.algo.ts:297
    // const proposalBox = this.proposals(proposalId)
    itob
    // smart_contracts/delegator/delegator.algo.ts:84
    // proposals = BoxMap<Application, DelegatorProposal>({ keyPrefix: 'P' })
    bytec 6 // "P"
    swap
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:298
    // ensure(proposalBox.exists, errProposalNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteExternal_after_if_else@20
    // smart_contracts/delegator/delegator.algo.ts:298
    // ensure(proposalBox.exists, errProposalNotExists)
    bytec 18 // "ERR:P_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteExternal_after_if_else@20:
    // smart_contracts/delegator/delegator.algo.ts:299
    // const proposal = clone(proposalBox.value)
    dup
    box_get
    swap
    dup
    cover 2
    bury 15
    assert // Box must have value
    // smart_contracts/delegator/delegator.algo.ts:301
    // ensure(proposal.status === 'VOTE', errState)
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    pushint 46 // 46
    extract_uint16
    substring3
    extract 2 0
    bytec 21 // "VOTE"
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteExternal_after_if_else@24
    // smart_contracts/delegator/delegator.algo.ts:301
    // ensure(proposal.status === 'VOTE', errState)
    pushbytes "ERR:ST"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteExternal_after_if_else@24:
    // smart_contracts/delegator/delegator.algo.ts:303
    // ensure(proposal.extVoteStartTime.asUint64() <= Global.latestTimestamp, errEarly)
    dup
    pushints 34 4 // 34, 4
    box_extract
    btoi
    global LatestTimestamp
    <=
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteExternal_after_if_else@28
    // smart_contracts/delegator/delegator.algo.ts:303
    // ensure(proposal.extVoteStartTime.asUint64() <= Global.latestTimestamp, errEarly)
    bytec 19 // "ERR:EAR"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteExternal_after_if_else@28:
    // smart_contracts/delegator/delegator.algo.ts:304
    // ensure(Global.latestTimestamp < proposal.extVoteEndTime.asUint64(), errLate)
    global LatestTimestamp
    dig 1
    pushints 38 4 // 38, 4
    box_extract
    btoi
    <
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteExternal_after_if_else@32
    // smart_contracts/delegator/delegator.algo.ts:304
    // ensure(Global.latestTimestamp < proposal.extVoteEndTime.asUint64(), errLate)
    bytec 20 // "ERR:LAT"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteExternal_after_if_else@32:
    // smart_contracts/delegator/delegator.algo.ts:305
    // ensure(proposal.intVotedAlgohours > 0, errNoVotes)
    dup
    pushint 62 // 62
    intc_2 // 8
    box_extract
    btoi
    dup
    bury 7
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteExternal_after_if_else@36
    // smart_contracts/delegator/delegator.algo.ts:305
    // ensure(proposal.intVotedAlgohours > 0, errNoVotes)
    pushbytes "ERR:NV"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteExternal_after_if_else@36:
    // smart_contracts/delegator/delegator.algo.ts:306
    // ensure(extAccounts.length === proposal.extAccountsPendingVotes.length, errAccountNumMismatch)
    dupn 2
    pushints 46 2 // 46, 2
    box_extract
    btoi
    pushint 2 // 2
    box_extract
    btoi
    dig 2
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz voteExternal_after_if_else@40
    // smart_contracts/delegator/delegator.algo.ts:306
    // ensure(extAccounts.length === proposal.extAccountsPendingVotes.length, errAccountNumMismatch)
    pushbytes "ERR:ANM"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

voteExternal_after_if_else@40:
    // smart_contracts/delegator/delegator.algo.ts:308
    // let totalApprovals: uint64 = 0
    intc_0 // 0
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:309
    // let totalRejections: uint64 = 0
    intc_0 // 0
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:310
    // const isBoycott = proposal.intVotesBoycottAlgohours * 2 >= proposal.intTotalAlgohours
    dupn 2
    pushint 94 // 94
    intc_2 // 8
    box_extract
    btoi
    pushint 2 // 2
    *
    swap
    pushint 54 // 54
    intc_2 // 8
    box_extract
    btoi
    dup
    bury 7
    >=
    dup
    bury 10
    // smart_contracts/delegator/delegator.algo.ts:311
    // if (!isBoycott) {
    bnz voteExternal_after_if_else@6
    // smart_contracts/delegator/delegator.algo.ts:312
    // const denominator = this.absenteeMode.value === 'scaled' ? proposal.intVotedAlgohours : proposal.intTotalAlgohours
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:80
    // absenteeMode = GlobalState<string>({ initialValue: 'strict' })
    bytec 12 // "absenteeMode"
    // smart_contracts/delegator/delegator.algo.ts:312
    // const denominator = this.absenteeMode.value === 'scaled' ? proposal.intVotedAlgohours : proposal.intTotalAlgohours
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes "scaled"
    ==
    bz voteExternal_ternary_false@4
    dig 5

voteExternal_ternary_merge@5:
    // smart_contracts/delegator/delegator.algo.ts:313
    // totalApprovals = (proposal.intVotesYesAlgohours * proposal.extTotalVotingPower.asUint64()) / denominator
    dig 1
    dup
    pushint 70 // 70
    intc_2 // 8
    box_extract
    btoi
    dig 1
    pushints 42 4 // 42, 4
    box_extract
    btoi
    swap
    dig 1
    *
    dig 3
    /
    bury 11
    // smart_contracts/delegator/delegator.algo.ts:314
    // totalRejections = (proposal.intVotesNoAlgohours * proposal.extTotalVotingPower.asUint64()) / denominator
    swap
    pushint 78 // 78
    intc_2 // 8
    box_extract
    btoi
    *
    swap
    /
    bury 7

voteExternal_after_if_else@6:
    // smart_contracts/delegator/delegator.algo.ts:319
    // for (let i: uint64 = 0; i < extAccounts.length; i++) {
    intc_0 // 0
    bury 10

voteExternal_while_top@7:
    // smart_contracts/delegator/delegator.algo.ts:319
    // for (let i: uint64 = 0; i < extAccounts.length; i++) {
    dig 9
    dig 2
    <
    bz voteExternal_after_while@13
    // smart_contracts/delegator/delegator.algo.ts:320
    // const extAccount = extAccounts[i]
    dig 2
    extract 2 0
    dig 10
    dup
    cover 2
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    dup
    bury 18
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 9 // "a"
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:321
    // const extAccountId = this.accountIds(extAccount).value
    box_get
    assert // Box must have value
    // smart_contracts/delegator/delegator.algo.ts:322
    // const extAccountsPendingVote = clone(proposal.extAccountsPendingVotes[i])
    dig 14
    dup
    pushint 46 // 46
    extract_uint16
    dig 1
    pushint 48 // 48
    extract_uint16
    dup
    bury 17
    substring3
    extract 2 0
    dig 2
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    dup
    bury 18
    // smart_contracts/delegator/delegator.algo.ts:322-323
    // const extAccountsPendingVote = clone(proposal.extAccountsPendingVotes[i])
    // ensureExtra(extAccountId === extAccountsPendingVote.accountId, errAccountIdMismatch, op.itob(i))
    extract 0 4
    // smart_contracts/delegator/delegator.algo.ts:323
    // ensureExtra(extAccountId === extAccountsPendingVote.accountId, errAccountIdMismatch, op.itob(i))
    ==
    swap
    itob
    bury 15
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz voteExternal_after_if_else@16
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 13
    log
    // smart_contracts/delegator/delegator.algo.ts:323
    // ensureExtra(extAccountId === extAccountsPendingVote.accountId, errAccountIdMismatch, op.itob(i))
    pushbytes "ERR:ID"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

voteExternal_after_if_else@16:
    // smart_contracts/delegator/delegator.algo.ts:327
    // if (isBoycott) {
    dig 8
    bz voteExternal_else_body@10
    // smart_contracts/delegator/delegator.algo.ts:328
    // approvals = extAccountsPendingVote.votes.asUint64()
    dig 14
    pushint 4 // 4
    extract_uint32
    dup
    bury 12

voteExternal_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:337-340
    // compileArc4(XGovProposalMock).call.vote({
    //   appId: proposalId,
    //   args: [extAccount, approvals, rejections],
    // })
    itxn_begin
    // smart_contracts/delegator/delegator.algo.ts:339
    // args: [extAccount, approvals, rejections],
    dig 11
    itob
    swap
    itob
    // smart_contracts/delegator/delegator.algo.ts:337-340
    // compileArc4(XGovProposalMock).call.vote({
    //   appId: proposalId,
    //   args: [extAccount, approvals, rejections],
    // })
    pushbytes 0x1841a0d2 // method "vote(address,uint64,uint64)string"
    itxn_field ApplicationArgs
    dig 17
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    intc_0 // 0
    itxn_field OnCompletion
    dig 3
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/delegator/delegator.algo.ts:341
    // proposal.extAccountsVoted.push(extAccountsPendingVote)
    dig 12
    dup
    len
    dig 1
    dig 14
    dup
    cover 4
    uncover 2
    substring3
    dup
    dig 18
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    swap
    intc_0 // 0
    uncover 3
    extract3
    swap
    concat
    bury 13
    // smart_contracts/delegator/delegator.algo.ts:319
    // for (let i: uint64 = 0; i < extAccounts.length; i++) {
    dig 9
    intc_1 // 1
    +
    bury 10
    b voteExternal_while_top@7

voteExternal_else_body@10:
    // smart_contracts/delegator/delegator.algo.ts:332
    // approvals = (totalApprovals * extAccountsPendingVote.votes.asUint64()) / proposal.extTotalVotingPower.asUint64()
    dig 14
    pushint 4 // 4
    extract_uint32
    dig 8
    dig 1
    *
    dig 14
    pushint 42 // 42
    extract_uint32
    swap
    dig 1
    /
    bury 13
    // smart_contracts/delegator/delegator.algo.ts:334
    // (totalRejections * extAccountsPendingVote.votes.asUint64()) / proposal.extTotalVotingPower.asUint64()
    dig 8
    uncover 2
    *
    swap
    /
    b voteExternal_after_if_else@11

voteExternal_after_while@13:
    // smart_contracts/delegator/delegator.algo.ts:343
    // proposal.extAccountsPendingVotes = []
    dig 12
    dup
    pushint 46 // 46
    extract_uint16
    dig 1
    intc_0 // 0
    dig 2
    extract3
    bytec 16 // 0x0000
    concat
    dig 2
    pushint 48 // 48
    extract_uint16
    dig 3
    len
    uncover 4
    dig 2
    uncover 2
    substring3
    uncover 2
    swap
    concat
    dig 1
    uncover 3
    -
    uncover 2
    pushint 2 // 2
    +
    swap
    -
    itob
    extract 6 2
    replace2 48
    // smart_contracts/delegator/delegator.algo.ts:344
    // proposal.status = 'VOTD'
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_0 // 0
    dig 2
    extract3
    pushbytes 0x0004564f5444
    concat
    dig 2
    pushint 46 // 46
    extract_uint16
    dig 3
    len
    dig 4
    dig 2
    uncover 2
    substring3
    uncover 2
    swap
    concat
    dig 1
    uncover 3
    -
    uncover 2
    pushint 6 // 6
    +
    dig 1
    -
    itob
    extract 6 2
    uncover 2
    swap
    replace2 46
    uncover 2
    pushint 48 // 48
    extract_uint16
    pushint 6 // 6
    +
    uncover 2
    -
    itob
    extract 6 2
    replace2 48
    // smart_contracts/delegator/delegator.algo.ts:345
    // proposalBox.value = clone(proposal)
    dig 1
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/delegator/delegator.algo.ts:296
    // public voteExternal(proposalId: Application, extAccounts: Account[]): void {
    intc_1 // 1
    return

voteExternal_ternary_false@4:
    dig 4
    b voteExternal_ternary_merge@5


// smart_contracts/delegator/delegator.algo.ts::Delegator.addAccountAlgoHours[routing]() -> void:
addAccountAlgoHours:
    intc_0 // 0
    dupn 3
    bytec_1 // ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:353
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:354
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:355
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@15
    // smart_contracts/delegator/delegator.algo.ts:355
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

addAccountAlgoHours_after_if_else@15:
    intc_0 // 0
    bury 4

addAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:357
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz addAccountAlgoHours_after_for@8
    dig 1
    extract 2 0
    dig 4
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 11
    intc_3 // 32
    extract_uint64
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:358
    // const accountId = this.getOrCreateAccountId(account)
    callsub getOrCreateAccountId
    // smart_contracts/delegator/delegator.algo.ts:359
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:88
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 8 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:361
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bz addAccountAlgoHours_after_if_else@11
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:361
    // ensureExtra(!box.exists, errAlgoHoursExist, account.bytes)
    pushbytes "ERR:AH_EX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

addAccountAlgoHours_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:362
    // box.value = hours
    dig 4
    itob
    dup
    bury 7
    dig 7
    swap
    box_put
    // smart_contracts/delegator/delegator.algo.ts:86
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_3 // "H"
    dig 8
    concat
    dup
    // smart_contracts/delegator/delegator.algo.ts:365
    // if (totalBox.exists) {
    box_len
    bury 1
    bz addAccountAlgoHours_else_body@5
    // smart_contracts/delegator/delegator.algo.ts:366
    // totalBox.value.totalAlgohours += hours
    dup
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    +
    itob
    intc_0 // 0
    swap
    box_replace

addAccountAlgoHours_after_if_else@6:
    dig 3
    intc_1 // 1
    +
    bury 4
    b addAccountAlgoHours_for_header@2

addAccountAlgoHours_else_body@5:
    // smart_contracts/delegator/delegator.algo.ts:368
    // totalBox.value = { totalAlgohours: hours, final: false }
    dig 6
    pushbytes 0x00
    concat
    box_put
    b addAccountAlgoHours_after_if_else@6

addAccountAlgoHours_after_for@8:
    // smart_contracts/delegator/delegator.algo.ts:353
    // public addAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.removeAccountAlgoHours[routing]() -> void:
removeAccountAlgoHours:
    intc_0 // 0
    dupn 3
    bytec_1 // ""
    dup
    // smart_contracts/delegator/delegator.algo.ts:378
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 40 // 40
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<smart_contracts/base/types.algo.ts::AccountAlgohourInput>
    // smart_contracts/delegator/delegator.algo.ts:379
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:380
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz removeAccountAlgoHours_after_if_else@20
    // smart_contracts/delegator/delegator.algo.ts:380
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@20:
    intc_0 // 0
    bury 4

removeAccountAlgoHours_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:382
    // for (let { account, hours } of clone(accountAlgohourInputs)) {
    dig 3
    dig 1
    <
    bz removeAccountAlgoHours_after_for@5
    dig 1
    extract 2 0
    dig 4
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: index access is out of bounds
    dup
    extract 0 32
    dup
    cover 2
    bury 11
    intc_3 // 32
    extract_uint64
    bury 6
    // smart_contracts/delegator/delegator.algo.ts:383
    // const accountId = this.mustGetAccountId(account)
    callsub mustGetAccountId
    // smart_contracts/delegator/delegator.algo.ts:384
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 3
    itob
    dup
    bury 10
    swap
    concat
    // smart_contracts/delegator/delegator.algo.ts:88
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 8 // "h"
    swap
    concat
    dup
    bury 8
    // smart_contracts/delegator/delegator.algo.ts:386
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@8
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:386
    // ensureExtra(box.exists, errAlgoHoursNotExist, account.bytes)
    bytec 7 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@8:
    // smart_contracts/delegator/delegator.algo.ts:387
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    dig 6
    box_get
    assert // Box must have value
    btoi
    dig 5
    ==
    // smart_contracts/base/utils.algo.ts:16
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@12
    // smart_contracts/base/utils.algo.ts:17
    // log(extra)
    dig 8
    log
    // smart_contracts/delegator/delegator.algo.ts:387
    // ensureExtra(box.value === hours, errAlgoHoursMismatch, account.bytes) // ensure hours to remove matches existing hours to prevent accidental double removal
    bytec 22 // "ERR:AH"
    // smart_contracts/base/utils.algo.ts:18
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:19
    // err()
    err

removeAccountAlgoHours_after_if_else@12:
    // smart_contracts/delegator/delegator.algo.ts:388
    // box.delete()
    dig 6
    box_del
    pop
    // smart_contracts/delegator/delegator.algo.ts:86
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_3 // "H"
    dig 8
    concat
    dup
    bury 7
    // smart_contracts/delegator/delegator.algo.ts:391
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz removeAccountAlgoHours_after_if_else@16
    // smart_contracts/delegator/delegator.algo.ts:391
    // ensure(totalBox.exists, errAlgoHoursNotExist)
    bytec 7 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

removeAccountAlgoHours_after_if_else@16:
    // smart_contracts/delegator/delegator.algo.ts:392
    // totalBox.value.totalAlgohours -= hours
    dig 5
    dup
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 6
    -
    itob
    intc_0 // 0
    swap
    box_replace
    dig 3
    intc_1 // 1
    +
    bury 4
    b removeAccountAlgoHours_for_header@2

removeAccountAlgoHours_after_for@5:
    // smart_contracts/delegator/delegator.algo.ts:378
    // public removeAccountAlgoHours(periodStart: uint64, accountAlgohourInputs: AccountAlgohourInput[]): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.updateAlgoHourPeriodFinality[routing]() -> void:
updateAlgoHourPeriodFinality:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:401
    // public updateAlgoHourPeriodFinality(periodStart: uint64, totalAlgohours: uint64, final: boolean): void {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    swap
    // smart_contracts/delegator/delegator.algo.ts:402
    // this.ensureCallerIsAdmin()
    callsub ensureCallerIsAdmin
    // smart_contracts/delegator/delegator.algo.ts:403
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz updateAlgoHourPeriodFinality_after_if_else@3
    // smart_contracts/delegator/delegator.algo.ts:403
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@3:
    // smart_contracts/delegator/delegator.algo.ts:404
    // const box = this.algohourPeriodTotals(periodStart)
    dig 2
    itob
    // smart_contracts/delegator/delegator.algo.ts:86
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_3 // "H"
    swap
    concat
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:405
    // ensure(box.exists, errAlgoHoursNotExist)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz updateAlgoHourPeriodFinality_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:405
    // ensure(box.exists, errAlgoHoursNotExist)
    bytec 7 // "ERR:AH_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:406
    // ensure(box.value.totalAlgohours === totalAlgohours, errAlgoHoursMismatch)
    dig 3
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    dig 2
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz updateAlgoHourPeriodFinality_after_if_else@11
    // smart_contracts/delegator/delegator.algo.ts:406
    // ensure(box.value.totalAlgohours === totalAlgohours, errAlgoHoursMismatch)
    bytec 22 // "ERR:AH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

updateAlgoHourPeriodFinality_after_if_else@11:
    // smart_contracts/delegator/delegator.algo.ts:407
    // box.value.final = final
    dig 3
    dup
    intc_2 // 8
    intc_1 // 1
    box_extract
    intc_0 // 0
    dig 3
    setbit
    intc_2 // 8
    swap
    box_replace
    // smart_contracts/delegator/delegator.algo.ts:401
    // public updateAlgoHourPeriodFinality(periodStart: uint64, totalAlgohours: uint64, final: boolean): void {
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAlgoHourPeriodTotals[routing]() -> void:
getAlgoHourPeriodTotals:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:443
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/delegator/delegator.algo.ts:445
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAlgoHourPeriodTotals_after_if_else@7
    // smart_contracts/delegator/delegator.algo.ts:445
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAlgoHourPeriodTotals_after_if_else@7:
    // smart_contracts/delegator/delegator.algo.ts:446
    // const box = this.algohourPeriodTotals(periodStart)
    dup
    itob
    // smart_contracts/delegator/delegator.algo.ts:86
    // algohourPeriodTotals = BoxMap<uint64, AlgohourPeriodTotals>({ keyPrefix: 'H' })
    bytec_3 // "H"
    swap
    concat
    dup
    bury 3
    // smart_contracts/delegator/delegator.algo.ts:447
    // return box.exists ? box.value : { totalAlgohours: 0, final: false }
    box_len
    bury 1
    bz getAlgoHourPeriodTotals_ternary_false@3
    dig 1
    box_get
    assert // Box must have value

getAlgoHourPeriodTotals_ternary_merge@4:
    // smart_contracts/delegator/delegator.algo.ts:443
    // @abimethod({ readonly: true })
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAlgoHourPeriodTotals_ternary_false@3:
    // smart_contracts/delegator/delegator.algo.ts:447
    // return box.exists ? box.value : { totalAlgohours: 0, final: false }
    pushbytes 0x000000000000000000
    b getAlgoHourPeriodTotals_ternary_merge@4


// smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours[routing]() -> void:
getAccountAlgoHours:
    intc_0 // 0
    dup
    // smart_contracts/delegator/delegator.algo.ts:456
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    cover 2
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/delegator/delegator.algo.ts:458
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    intc 4 // 1000000
    %
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getAccountAlgoHours_after_if_else@10
    // smart_contracts/delegator/delegator.algo.ts:458
    // ensure(periodStart % periodLength === 0, errPeriodStartInvalid)
    bytec_2 // "ERR:PS"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getAccountAlgoHours_after_if_else@10:
    // smart_contracts/delegator/delegator.algo.ts:459
    // const accountId = this.getAccountIdIfExists(account)
    dup
    callsub getAccountIdIfExists
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:460
    // if (accountId.asUint64() === 0) {
    btoi
    bnz getAccountAlgoHours_after_if_else@3
    // smart_contracts/delegator/delegator.algo.ts:461
    // return 0
    intc_0 // 0

getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7:
    // smart_contracts/delegator/delegator.algo.ts:456
    // @abimethod({ readonly: true })
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getAccountAlgoHours_after_if_else@3:
    // smart_contracts/delegator/delegator.algo.ts:463
    // const key: AlgohourAccountKey = [periodStart, accountId]
    dig 1
    itob
    dig 4
    concat
    // smart_contracts/delegator/delegator.algo.ts:88
    // algohourAccounts = BoxMap<AlgohourAccountKey, uint64>({ keyPrefix: 'h' })
    bytec 8 // "h"
    swap
    concat
    dup
    bury 4
    // smart_contracts/delegator/delegator.algo.ts:465
    // return box.exists ? box.value : 0
    box_len
    bury 1
    bz getAccountAlgoHours_ternary_false@5
    dig 2
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/delegator/delegator.algo.ts:456
    // @abimethod({ readonly: true })
    b getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7

getAccountAlgoHours_ternary_false@5:
    // smart_contracts/delegator/delegator.algo.ts:465
    // return box.exists ? box.value : 0
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:456
    // @abimethod({ readonly: true })
    b getAccountAlgoHours_after_inlined_smart_contracts/delegator/delegator.algo.ts::Delegator.getAccountAlgoHours@7


// smart_contracts/delegator/delegator.algo.ts::Delegator.logCommitteeMetadata[routing]() -> void:
logCommitteeMetadata:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:472
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_3 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.static_array<arc4.uint8, 32>>
    intc_0 // 0

logCommitteeMetadata_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:474
    // for (const committeeId of committeeIds) {
    dup
    dig 2
    <
    bz logCommitteeMetadata_after_for@8
    dig 2
    extract 2 0
    dig 1
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/delegator/delegator.algo.ts:82
    // committees = BoxMap<CommitteeId, DelegatorCommittee>({ keyPrefix: 'C' })
    bytec 5 // "C"
    swap
    concat
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:476
    // if (metadata.exists) {
    box_len
    bury 1
    bz logCommitteeMetadata_else_body@5
    // smart_contracts/delegator/delegator.algo.ts:477
    // log(encodeArc4(metadata.value))
    dig 3
    box_get
    assert // Box must have value
    log

logCommitteeMetadata_after_if_else@6:
    dup
    intc_1 // 1
    +
    bury 1
    b logCommitteeMetadata_for_header@2

logCommitteeMetadata_else_body@5:
    // smart_contracts/base/types.algo.ts:76
    // periodStart: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/base/types.algo.ts:77
    // periodEnd: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/base/types.algo.ts:78
    // extDelegatedVotes: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/base/types.algo.ts:75-80
    // return {
    //   periodStart: u32(0),
    //   periodEnd: u32(0),
    //   extDelegatedVotes: u32(0),
    //   extDelegatedAccountVotes: [] as AccountIdWithVotes[],
    // }
    cover 2
    concat
    swap
    concat
    bytec 13 // 0x000e0000
    concat
    // smart_contracts/delegator/delegator.algo.ts:479
    // log(encodeArc4(getEmptyDelegatorCommittee()))
    log
    b logCommitteeMetadata_after_if_else@6

logCommitteeMetadata_after_for@8:
    // smart_contracts/delegator/delegator.algo.ts:472
    // @abimethod({ readonly: true })
    intc_1 // 1
    return


// smart_contracts/delegator/delegator.algo.ts::Delegator.logProposalMetadata[routing]() -> void:
logProposalMetadata:
    intc_0 // 0
    // smart_contracts/delegator/delegator.algo.ts:488
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<application>
    intc_0 // 0

logProposalMetadata_for_header@2:
    // smart_contracts/delegator/delegator.algo.ts:490
    // for (const proposalId of proposalIds) {
    dup
    dig 2
    <
    bz logProposalMetadata_after_for@8
    dig 2
    extract 2 0
    dig 1
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    // smart_contracts/delegator/delegator.algo.ts:84
    // proposals = BoxMap<Application, DelegatorProposal>({ keyPrefix: 'P' })
    bytec 6 // "P"
    swap
    concat
    dup
    bury 5
    // smart_contracts/delegator/delegator.algo.ts:492
    // if (metadata.exists) {
    box_len
    bury 1
    bz logProposalMetadata_else_body@5
    // smart_contracts/delegator/delegator.algo.ts:493
    // log(encodeArc4(metadata.value))
    dig 3
    box_get
    assert // Box must have value
    log

logProposalMetadata_after_if_else@6:
    dup
    intc_1 // 1
    +
    bury 1
    b logProposalMetadata_for_header@2

logProposalMetadata_else_body@5:
    // smart_contracts/base/types.algo.ts:111
    // extVoteStartTime: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/base/types.algo.ts:112
    // extVoteEndTime: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/base/types.algo.ts:113
    // extTotalVotingPower: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/base/types.algo.ts:114
    // extAccountsPendingVotes: [] as AccountIdWithVotes[],
    intc_0 // 0
    itob
    // smart_contracts/base/types.algo.ts:116
    // intVoteEndTime: u32(0),
    intc_0 // 0
    callsub u32
    // smart_contracts/base/types.algo.ts:108-123
    // return {
    //   status: '' as DelegatorProposalStatus,
    //   committeeId: new StaticBytes<32>(),
    //   extVoteStartTime: u32(0),
    //   extVoteEndTime: u32(0),
    //   extTotalVotingPower: u32(0),
    //   extAccountsPendingVotes: [] as AccountIdWithVotes[],
    //   extAccountsVoted: [] as AccountIdWithVotes[],
    //   intVoteEndTime: u32(0),
    //   intTotalAlgohours: 0,
    //   intVotedAlgohours: 0,
    //   intVotesYesAlgohours: 0,
    //   intVotesNoAlgohours: 0,
    //   intVotesAbstainAlgohours: 0,
    //   intVotesBoycottAlgohours: 0,
    // }
    pushbytes 0x00660000000000000000000000000000000000000000000000000000000000000000
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    pushbytes 0x0068006a
    concat
    swap
    concat
    dig 1
    concat
    dig 1
    concat
    dig 1
    concat
    dig 1
    concat
    dig 1
    concat
    swap
    concat
    pushbytes 0x000000000000
    concat
    // smart_contracts/delegator/delegator.algo.ts:495
    // log(encodeArc4(getEmptyDelegatorProposal()))
    log
    b logProposalMetadata_after_if_else@6

logProposalMetadata_after_for@8:
    // smart_contracts/delegator/delegator.algo.ts:488
    // @abimethod({ readonly: true })
    intc_1 // 1
    return


// smart_contracts/base/base.algo.ts::AccountIdContract.increaseBudget[routing]() -> void:
increaseBudget:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    intc_0 // 0

increaseBudget_while_top@2:
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    dig 2
    <
    bz increaseBudget_after_while@5
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/base/base.algo.ts:95
    // onCompletion: OnCompleteAction.DeleteApplication,
    pushint 5 // 5
    itxn_field OnCompletion
    // smart_contracts/base/base.algo.ts:89
    // const empty = compile(EmptyContract)
    bytec 23 // base64(C4EBQw==)
    itxn_field ClearStateProgramPages
    bytec 23 // base64(C4EBQw==)
    itxn_field ApprovalProgramPages
    // smart_contracts/base/base.algo.ts:91-96
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/base/base.algo.ts:91-97
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/base/base.algo.ts:90
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    intc_1 // 1
    +
    bury 1
    b increaseBudget_while_top@2

increaseBudget_after_while@5:
    // smart_contracts/base/base.algo.ts:87
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_1 // 1
    return


// smart_contracts/base/base.algo.ts::AccountIdContract.getAccountIdIfExists(account: bytes) -> bytes:
getAccountIdIfExists:
    // smart_contracts/base/base.algo.ts:43
    // protected getAccountIdIfExists(account: Account): Uint32 {
    proto 1 1
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 9 // "a"
    frame_dig -1
    concat
    dup
    // smart_contracts/base/base.algo.ts:45
    // if (box.exists) return box.value
    box_len
    bury 1
    bz getAccountIdIfExists_else_body@2
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub

getAccountIdIfExists_else_body@2:
    // smart_contracts/base/base.algo.ts:46
    // else return u32(0)
    intc_0 // 0
    callsub u32
    swap
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.mustGetAccountId(account: bytes) -> bytes:
mustGetAccountId:
    // smart_contracts/base/base.algo.ts:55
    // protected mustGetAccountId(account: Account): Uint32 {
    proto 1 1
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 9 // "a"
    frame_dig -1
    concat
    dup
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz mustGetAccountId_after_if_else@3
    // smart_contracts/base/base.algo.ts:57
    // ensure(accountIdBox.exists, errAccountNotExists)
    pushbytes "ERR:A_NX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

mustGetAccountId_after_if_else@3:
    // smart_contracts/base/base.algo.ts:58
    // return accountIdBox.value
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.getOrCreateAccountId(account: bytes) -> bytes:
getOrCreateAccountId:
    // smart_contracts/base/base.algo.ts:66
    // protected getOrCreateAccountId(account: Account): Uint32 {
    proto 1 1
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:67
    // let accountId = this.getAccountIdIfExists(account)
    frame_dig -1
    callsub getAccountIdIfExists
    dup
    // smart_contracts/base/base.algo.ts:68
    // if (accountId.asUint64() === 0) {
    btoi
    bnz getOrCreateAccountId_else_body@2
    // smart_contracts/base/base.algo.ts:21
    // accountIds = BoxMap<Account, Uint32>({ keyPrefix: 'a' })
    bytec 9 // "a"
    frame_dig -1
    concat
    dup
    frame_bury 0
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    box_len
    bury 1
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bz getOrCreateAccountId_after_if_else@5
    // smart_contracts/base/base.algo.ts:31
    // ensure(!box.exists, errAccountExists)
    pushbytes "ERR:A_EX"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

getOrCreateAccountId_after_if_else@5:
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    intc_0 // 0
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec 10 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/base/base.algo.ts:20
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    bytec 10 // "lastAccountId"
    // smart_contracts/base/base.algo.ts:32
    // this.lastAccountId.value++
    dig 1
    app_global_put
    // smart_contracts/base/base.algo.ts:33
    // const accountId = u32(this.lastAccountId.value)
    callsub u32
    // smart_contracts/base/base.algo.ts:34
    // box.value = accountId
    frame_dig 0
    dig 1
    box_put
    // smart_contracts/base/base.algo.ts:69
    // return this.createAccountId(account)
    frame_bury 0
    retsub

getOrCreateAccountId_else_body@2:
    // smart_contracts/base/base.algo.ts:71
    // return accountId
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/base/base.algo.ts::AccountIdContract.ensureCallerIsAdmin() -> void:
ensureCallerIsAdmin:
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/base/utils.algo.ts:9
    // if (!cond) {
    bnz ensureCallerIsAdmin_after_if_else@3
    // smart_contracts/base/base.algo.ts:80
    // ensure(Txn.sender === Global.creatorAddress, errUnauthorized)
    bytec 17 // "ERR:AUTH"
    // smart_contracts/base/utils.algo.ts:10
    // log(code)
    log
    // smart_contracts/base/utils.algo.ts:11
    // err()
    err

ensureCallerIsAdmin_after_if_else@3:
    retsub
