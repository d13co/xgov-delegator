#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 32
    bytecblock base64(C4EBQw==)
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/oracle/oracle-account.algo.ts:15
    // lastAccountId = GlobalState<uint64>({ initialValue: 0 })
    pushbytes "lastAccountId"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/oracle/oracle-account.algo.ts:13
    // export class OracleAccountContract extends BaseContract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@12
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xc60713f2 0xa220b9f9 0x4118ecbf // method "getAccount(address)(uint32,(uint16,uint16)[])", method "logAccounts(address[])void", method "increaseBudget(uint64)void"
    txna ApplicationArgs 0
    match getAccount logAccounts increaseBudget
    err

main___algots__.defaultCreate@12:
    // smart_contracts/oracle/oracle-account.algo.ts:13
    // export class OracleAccountContract extends BaseContract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// smart_contracts/oracle/oracle-account.algo.ts::OracleAccountContract.getAccount[routing]() -> void:
getAccount:
    // smart_contracts/oracle/oracle-account.algo.ts:127
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/oracle/oracle-account.algo.ts:129
    // return this.getAccountIfExists(account)
    callsub getAccountIfExists
    // smart_contracts/oracle/oracle-account.algo.ts:127
    // @abimethod({ readonly: true })
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts/oracle/oracle-account.algo.ts::OracleAccountContract.logAccounts[routing]() -> void:
logAccounts:
    // smart_contracts/oracle/oracle-account.algo.ts:137
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dupn 2
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 32
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<account>
    intc_1 // 0

logAccounts_for_header@2:
    // smart_contracts/oracle/oracle-account.algo.ts:139
    // for (const account of accounts) {
    dup
    dig 2
    <
    bz logAccounts_after_for@5
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 32
    *
    intc_2 // 32
    extract3 // on error: index access is out of bounds
    // smart_contracts/oracle/oracle-account.algo.ts:140
    // log(encodeArc4(this.getAccountIfExists(account)))
    callsub getAccountIfExists
    log
    intc_0 // 1
    +
    bury 1
    b logAccounts_for_header@2

logAccounts_after_for@5:
    // smart_contracts/oracle/oracle-account.algo.ts:137
    // @abimethod({ readonly: true })
    intc_0 // 1
    return


// smart_contracts/base/base.algo.ts::BaseContract.increaseBudget[routing]() -> void:
increaseBudget:
    // smart_contracts/base/base.algo.ts:21
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    txna ApplicationArgs 1
    btoi
    // smart_contracts/base/base.algo.ts:24
    // for (let i: uint64 = 0; i < itxns; i++) {
    intc_1 // 0

increaseBudget_while_top@2:
    // smart_contracts/base/base.algo.ts:24
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    dig 2
    <
    bz increaseBudget_after_while@5
    // smart_contracts/base/base.algo.ts:25-31
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/base/base.algo.ts:29
    // onCompletion: OnCompleteAction.DeleteApplication,
    pushint 5 // 5
    itxn_field OnCompletion
    // smart_contracts/base/base.algo.ts:23
    // const empty = compile(EmptyContract)
    bytec_0 // base64(C4EBQw==)
    itxn_field ClearStateProgramPages
    bytec_0 // base64(C4EBQw==)
    itxn_field ApprovalProgramPages
    // smart_contracts/base/base.algo.ts:25-30
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/base/base.algo.ts:25-31
    // itxn
    //   .applicationCall({
    //     approvalProgram: empty.clearStateProgram, // intentionally using clear state program for "return true"
    //     clearStateProgram: empty.clearStateProgram,
    //     onCompletion: OnCompleteAction.DeleteApplication,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/base/base.algo.ts:24
    // for (let i: uint64 = 0; i < itxns; i++) {
    dup
    intc_0 // 1
    +
    bury 1
    b increaseBudget_while_top@2

increaseBudget_after_while@5:
    // smart_contracts/base/base.algo.ts:21
    // @abimethod({ validateEncoding: 'unsafe-disabled' })
    intc_0 // 1
    return


// smart_contracts/oracle/oracle-account.algo.ts::OracleAccountContract.getAccountIfExists(account: bytes) -> bytes:
getAccountIfExists:
    // smart_contracts/oracle/oracle-account.algo.ts:39
    // protected getAccountIfExists(account: Account): OracleAccount {
    proto 1 1
    // smart_contracts/oracle/oracle-account.algo.ts:17
    // accounts = BoxMap<Account, OracleAccount>({ keyPrefix: 'a' })
    pushbytes "a"
    frame_dig -1
    concat
    dup
    // smart_contracts/oracle/oracle-account.algo.ts:41
    // if (box.exists) return box.value
    box_len
    bury 1
    bz getAccountIfExists_else_body@2
    frame_dig 0
    box_get
    assert // Box must have value
    swap
    retsub

getAccountIfExists_else_body@2:
    // smart_contracts/oracle/oracle-account.algo.ts:47
    // return { accountId: accountId, committeeOffsets: [] }
    pushbytes 0x0000000000060000
    // smart_contracts/oracle/oracle-account.algo.ts:42
    // else return this.getEmptyOracleAccount(u32(0))
    swap
    retsub
